#include <unsupported/Eigen/Splines>
#include <Eigen/Dense> //3.2.4
#include <iostream>
#include "b-spline.h"

#ifdef _WIN32
#define ON_WINDOWS 1
#else
#define ON_WINDOWS 0
#endif

Eigen::Array< double, 1, Eigen::Dynamic > gen_knots(const double t_init, const double t_final, const int spl_degree, const int no_interv_nn, bool nonuniform)
{
    // TODO no_interv_nn < 2 => error
    double d = (t_final-t_init)/(4+(no_interv_nn-2));
    // d is the nonuniform interval base value (spacing produce intervals like this: 2*d, d,... , d, 2*d)

    Eigen::Array< double, 1, Eigen::Dynamic > knots(spl_degree*2 + no_interv_nn+1);

    // first and last knots
    knots.head(spl_degree) = Eigen::Array< double, 1, Eigen::Dynamic >::Constant(spl_degree, t_init);
    knots.tail(spl_degree) = Eigen::Array< double, 1, Eigen::Dynamic >::Constant(spl_degree, t_final);
    
    // intermediaries knots
    if(nonuniform)
    {    
        knots(spl_degree) = t_init;
        knots(spl_degree+1) = t_init+2*d;

        auto i = 0;
        for(i = 0; i < no_interv_nn-2; ++i)
        {
            knots(spl_degree+i+2) = knots(spl_degree+i+1)+d;
        }

        knots(spl_degree+2+i) = t_final; // = knots(spl_degree+2+i-1) + 2*d
    }
    else // uniform
    {
        knots.segment(spl_degree, no_interv_nn+1) = Eigen::Array< double, 1, Eigen::Dynamic >::LinSpaced(no_interv_nn+1, t_init, t_final);
    }
    return knots;
}

typedef Eigen::Spline<double, 3> Spline3d;

int main(int argc, char** argv)
{
    const int flatoutput_dim = 2;
    const int spline_dim = flatoutput_dim+1;
    const int flatoutput_deriv = 2;
    const int defoort_degree = flatoutput_deriv+2;
    const int spline_degree = defoort_degree - 1;
    const int no_interv_nn = 5;
    const int Ns = 12; //spl_degree*2 + no_interv_nn+1
    const double t_init = 0.0;
    const double t_final = 2.0;
	
    Eigen::Array< double, spline_dim, Ns > points;

    for(auto i = 0; i < flatoutput_dim; ++i)
    {
        points.row(i) = Eigen::RowVectorXd::LinSpaced(Ns, 0.0, 5.0);
    }
    std::cout << "Adding time" << std::endl;
    points.bottomRows(1) = Eigen::RowVectorXd::LinSpaced(Ns, t_init, t_final);
    std::cout << "Time added" << std::endl;

    Spline3d aux;
    std::cout << "Aux spline created" << std::endl;
    //Eigen::Spline< double, flatoutput_dim+1, spline_degree > aux2;
    //Eigen::Spline< double, flatoutput_dim+1, spline_degree > final_spline;
    // attention to degree in the thesis and elsewhere
    // underlying type, curve dim, degree (by default is Dynamic)
    std::cout << "final_spline spline created" << std::endl;

    //std::cout << "Knots created by eigen before fitting: " << std::endl << final_spline.knots() << std::endl;

    std::cout << "Fitting without konts param" << std::endl;
    //aux = Eigen::SplineFitting< Eigen::Spline< double, flatoutput_dim+1, spline_degree > >::Interpolate(
    //        points, spline_degree);

    //std::cout << "Knots created by eigen by default after fitting all points: " << std::endl << aux.knots() << std::endl;

    //aux2 = Eigen::SplineFitting<Eigen::Spline<double, flatoutput_dim, spline_degree>>::Interpolate(
    //        points, spline_degree); // should add knots?
    //std::cout << "Knots created by eigen after fitting part of the points: " << std::endl << aux.knots() << std::endl;
    //std::cout << "Knots created by eigen after fitting all points: " << std::endl << aux2.knots() << std::endl;
    //std::cout << "Internal Knots: " << std::endl << aux.knots().segment(spline_degree,no_interv_nn+1) << std::endl;
    std::cout << "Fitting with aux.konts() param" << std::endl;
    /*final_spline = Eigen::SplineFitting< Eigen::Spline< double, flatoutput_dim+1, spline_degree > >::Interpolate(
        points, spline_degree, aux.knots());*/
    //std::cout << SplineFitting<Spline<double, flatoutput_dim, spline_degree>>::Interpolate(
    //    points, spline_degree,  gen_knots(t_init, t_final, spline_degree, no_interv_nn)).ctrls() << std::endl; // should add knots?
    //std::cout << SplineFitting<Spline<double, flatoutput_dim, spline_degree>>::Interpolate(
    //    points, spline_degree).ctrls() << std::endl; // should add knots?

    //std::cout << "Control points: " << std::endl << b.ctrls() << std::endl;
    /*std::cout << "Knots of final_spline: " << std::endl << final_spline.knots() << std::endl;
    std::cout << "Ctrl pts create by eigen with default knots: " << std::endl << aux.ctrls() << std::endl;
    std::cout << "Ctrl pts create by eigen with specific knots: " << std::endl << final_spline.ctrls() << std::endl;*/
    //std::cout << "Knots gen by 'me' (nonuniform): " << std::endl << gen_knots(t_init, t_final, spline_degree, no_interv_nn, true).transpose() << std::endl;
    //std::cout << "Knots gen by 'me' (uniform): " << std::endl << gen_knots(t_init, t_final, spline_degree, no_interv_nn, false).transpose() << std::endl;
    //std::cout << "inter: " << std::endl << VectorXd::LinSpaced(no_interv_nn+1, t_init, t_final) << std::endl;

    if(ON_WINDOWS) system("pause");
    return 0;
}

\selectlanguage{english}
\part{Internship Contribution}

\chapter{Global Near-optimal Solution for Path Planning}
\lipsum[1]
\section{Description of the Problem}

\chapter{Algorithmic Approach}
\lipsum[1]
\newpage

\section{Optimizers}

There is a variety of numerical optimization packages implemented in many different programming languages available for solving optimization problems~\cite{pyopt-paper}. Each of them may have their own way of defining the optimization problem and may or may not support specific kinds of constraints (equations, inequations or boundaries).

For the initial implementation written in python two packages stood out as good, easy-to-use options for solving the constrained optimization problem that models the planning motion task.

\textbf{Scipy} is a vast open-source scientific package based on python that happens to have a minimization module. Within this module many minimization methods can be found. For this specific optimization problem, only the method SLSPQ was appropriate. It was the only one to handle constrained minimization where the constraints could be equations as well as inequations.

\textbf{pyOpt} is a much smaller ecosystem than Scipy that is specialized in optimization. It gathers many different numerical optimization algorithms some of them free and some licensed. Again, among all of them there were only a few suitable for this problem which were also free: SLSQP (same as the one implemented within Sicpy), PSQP and ALGENCAN.

SLSQP and PSQP are both SQP (for sequential quadratic programming) methods. A SQP method attempts to solve a nonlinearly constrained optimization problem where the object function and the constraints are twice continuously differentiable. It does so by modeling the object function ($\min f(x)$) at the current iterate $x_k$ by a quadratic programming subproblem and using the minimizer of this subproblem to define a new iterate $x_{k+1}$~\cite{Nocedal}.

The ALGENCAN method\todo[inline, size=\tiny]{describe algecan}

% Following we present briefly these three methods:

% \begin{itemize}

% \item SLSQP: optimizer is a sequential least squares programming algorithm which uses the Han–Powell quasi–Newton method with a BFGS update of the B–matrix and an L1–test function in the step–length algorithm. The optimizer uses a slightly modified version of Lawson and Hanson’s NNLS nonlinear least-squares solver

% \item PSQP
% \item ALGENCAN
% \end{itemize}

%\paragraph{Cost function} chosen was the $(t_{final}-t_{initial})^2$. This $J$ value yields to a convergence while the using only the difference does not (for a given accuracy). Also there is the Hessian problem: slsqp try to invert the Hessian matrix which will be virtually zero for a linear cost function (if zero the error \texttt{Singular matrix C in LSQ subproblem (Exit mode 6)} is shown when using \texttt{scipy} optimization module)

%The optimization problem for the first implementation:

% \begin{equation}
% 	\underset{(t_{final},C_0,\dotsc,C_{d+n_{knot}-2})}{\mathrm{min}} J = \int_{t_{initial}}^{t_{final}}dt
% \end{equation}

\begin{equation}
	\underset{(t_{final},C_0,\dotsc,C_{d+n_{knot}-2})}{\mathrm{min}} J = (t_{final}-t_{initial})^{2}
\end{equation}

under the following constraints $\forall k \in \{0,\dotsc,N_s -1\}$:
\begin{equation}%\label{eq:sysr4}
\left\lbrace\begin{array}{lcl}
    \varphi_1(z(t_{initial}),\dotsc,z^{(l-1)}(t_{initial})) & = & q_{initial}\\
    \varphi_1(z(t_{final}),\dotsc,z^{(l-1)}(t_{final})) & = & q_{final}\\
    \varphi_2(z(t_{initial}),\dotsc,z^{(l)}(t_{initial})) & = & u_{initial}\\
    \varphi_2(z(t_{final}),\dotsc,z^{(l)}(t_{final}))& = & u_{final}\\
    \varphi_2(z(t_k),\dotsc,z^{(l)}(t_k)) &\in& \mathcal{U}\\
    d_{O_m}(t_k) &\geq& \rho + r_m,\quad \forall O_m \in \mathcal{Q}_{occupied}
\end{array}\right.
\end{equation}

% \paragraph{Practical stuff for implementation}
% 
% $q \in \R^n$ and $u \in \R^m$. $N_s$ number of time steps used when computing the problem.
% 
% Number of equations: $2n + 2m$
% 
% Number of inequations: $N_s(m+\mathrm{card}(\mathcal{Q}_{occupied}))$

% \paragraph{OPTIMIZERS}\footnote{CFSQP, SNOPT, NLPQL and FSQP are licensed} CFSQP is the name of the solver used by Defoort.

% \paragraph{SCIPY} Constrained minimization

% "Method L-BFGS-B uses the L-BFGS-B algorithm [R106], [R107] for bound constrained minimization.

% Method TNC uses a truncated Newton algorithm [R105], [R108] to minimize a function with variables subject to bounds. This algorithm uses gradient information; it is also called Newton Conjugate-Gradient. It differs from the Newton-CG method described above as it wraps a C implementation and allows each variable to be given upper and lower bounds.

% Method COBYLA uses the Constrained Optimization BY Linear Approximation (COBYLA) method [R109], [10], [11]. The algorithm is based on linear approximations to the objective function and each constraint. The method wraps a FORTRAN implementation of the algorithm.

% Method SLSQP uses Sequential Least SQuares Programming to minimize a function of several variables with any combination of bounds, equality and inequality constraints. The method wraps the SLSQP Optimization subroutine originally implemented by Dieter Kraft [12]. Note that the wrapper handles infinite values in bounds by converting them into large floating values."

% \paragraph{PYOPT}
% "We can see that for this convex problem, the four SQP optimizers (SNOPT, NLPQL, SLSQP, and FSQP) provide the most accurate solutions for the specified convergence tolerance. The FSQP optimizer requires the largest number of evaluations of all SQP approaches, since it generates a feasible point at each iteration before solving the SQP subproblem."

% There are other two optimizers that work: PSQP ALGENCAN

\begin{itemize}
\item Problem with discretization

Try adding CONSTRAINTS related to max acceleration (\textcolor{red}{DONE})

For that we have to increase the maximum derivative order of the flat output needed so we calculate $[\dot{v}\ \dot{\omega}]$ building a $\varphi_3$ function

Also, the constraints to be added:
\[
	\varphi_3(z(t_k),\dotsc,z^{(l)}(t_k)) \in \mathcal{A}
\]
where $\mathcal{A}$ is the set of admissible acceleration values.

The function $\varphi_3$ is as follows:
\[
\begin{array}{l}
\varphi_3(z(t_k),\dotsc,z^{(3)}(t_k))=\\
=\left[\begin{array}{c}
\dot{v}\\
\dot{\omega}
\end{array}\right]
= \left[\begin{array}{c}
\frac{\partial}{\partial t}\|\dot{z}\|\\
\frac{\partial}{\partial t}\frac{(\dot{z}_1\ddot{z}_2-\dot{z}_2\ddot{z}_1)}{\|\dot{z}\|^2}
\end{array}\right] = \left[\begin{array}{c}
\frac{\dot{z}_1\ddot{z}_1 + \dot{z}_2\ddot{z}_2}{\|\dot{z}\|}\\
\frac{(\ddot{z}_1\ddot{z}_2+ z^{(3)}_2\dot{z}_1 - (\ddot{z}_2\ddot{z}_1+z^{(3)}_1\dot{z}_2))\|\dot{z}\|^2-2(\dot{z}_1\ddot{z}_2-\dot{z}_2\ddot{z}_1)\|\dot{z}\|\dot{v}}{\|\dot{z}\|^4}
\end{array}\right]
\end{array}
\]

% \item Error over max value
% \item change ACC according to the max speed

% Kludge to reach convergence was decreasing accuracy (increasing the value of the ACC option).
% 
% ACC equals to $0.5e-2$ works but seems really bad since the default value used on all algorithms based on the Dieter Kraft implementation in FORTRAN use $1e-6$.
% 
% In my opinion, this suggests an error on my optimization problem definition or it could be the simple fact that with so many constraints (over 700 constraints) it is hard to a have a high accuracy "at the same time"

\item Remake code using good objected oriented structure. It will be good for C++ part (\textcolor{red}{DONE})

\end{itemize}

% \includegraphics[width=0.5\textwidth]{./img/planning-sim-trajc.png}

% \includegraphics[width=0.5\textwidth]{./img/planning-sim-trajc-good.png}

% \includegraphics[width=0.5\textwidth]{./img/planning-sim-vw-good.png}

\paragraph{ONLINE}

$T_c$ and $T_p$ (planning horizon) "given" (arbitrary).

\[
	\tau_{k} = t_{initial}+kT_c\quad k \in \N
\]

Arbitrary detection radius for the robot sensors. Only if the obstacle characteristic position  is inside the detection zone the obstacle is considered detected. Using $2m$.

Evaluate for each time interval $[\tau_{k-1},\tau_k) (k \in \N)$ the trajectory beginning at $\tau_k$ until $\tau_k+T_p$:

\begin{equation}
	\underset{(C_{(0,\tau_k)},\dotsc,C_{(d+n_{knot}-2,\tau_k)})}{\mathrm{min}} J_{\tau_k} = \|\varphi_1(z(\tau_k+T_p,\tau_k),\dotsc,z^{(l-1)}(\tau_k+T_p,\tau_k))-q_{final}\|^2
\end{equation}

under the following constraints $\forall t \in [\tau_k, \tau_k+T_p]$:
\begin{equation}%\label{eq:sysr4}
\left\lbrace\begin{array}{lcl}
	\varphi_1(z(\tau_{k},\tau_{k}),\dotsc,z^{(l-1)}(\tau_k,\tau_k)) & = & q_{ref}(\tau_k,\tau_{k-1})\\
    \varphi_2(z(\tau_{k},\tau_{k}),\dotsc,z^{(l)}(\tau_k,\tau_k)) & = & u_{ref}(\tau_k,\tau_{k-1})\\
    \varphi_2(z(t,\tau_k),\dotsc,z^{(l)}(t,\tau_k)) &\in& \mathcal{U}\\
    d_{O_m}(t,\tau_k) &\geq& \rho + r_m,\quad \forall O_m \in \mathcal{O}(\tau_k)
\end{array}\right.
\end{equation}

The period $[\tau_{-1},\tau_0)$ is what is called by Defoort "the initialization phase" which considers: $$q_{ref}(\tau_0,\tau_{-1}) = q_{initial}$$ $$u_{ref}(\tau_0,\tau_{-1}) = u_{initial}$$ without no more further changes to the expressions above.


\paragraph{Practical stuff for implementation}

$q \in \R^n$ and $u \in \R^m$. $N_s$ number of time steps used when computing the problem.

Number of equations: $n + m$

Number of inequations (function of $\tau_k$): $N_s(m+\mathrm{card}(\mathcal{O}(\tau_k)))$

dependencies:
sudo apt-get install python python-dev libatlas-base-dev gcc gfortran g++

get source:
https://pypi.python.org/pypi/scipy

sudo python setup.py install

\section{The mobile robot}

For representing the mobile robot geometry in the planning plane a bounding circle was chosen.

\subsection{Unicycle kinetic model}

\subsection{Flat output formulation}
\pagebreak
\section{The obstacles}

% \begin{figure}
% 	\centering
% 	\includegraphics[width=.7\textwidth]{./img/obstacles-no-title.png}
% 	\caption{Obstacle representation.\label{fig:obstacles}}
% \end{figure}

Two different representations of an obstacle are supported. Obstacles can be seen as circles or convex polygons.

Representing an obstacle as a circle is probably the most simple way of doing so and has great advantages when
calculating point-to-obstacle distance compared to other representations.

Nevertheless, obstacles such as walls, boxes and shelves cannot be satisfactorily represented by circles.
Thus the need of a polygon representation.

%\subsubsection{Convex Polygon Obstacles}

\subsection{Robot-to-obstacle distance calculation for the convex polygon representation}

As sad before the robot's geometric form is represented by a circle.
When calculating the robot-to-obstacle distance this simplified representation is quite useful. 
The first approach to calculate the distance between a point and an obstacle represented by a convex polygon
was to separate the problem in three cases with a different expression for the distance computation each.
We see in the Figure~\ref{fig:convexpolygon} that the points $A$, $B$ and $C$ are placed in three different
regions with respect to the obstacle. $A$ is "between" the two lines ($r_{0,1}$ and $r_{0,3}$) that pass through
the vertex $0$ and are orthogonal to the the two adjacent edges. $B$ is "between" the edge $s_{3}$, and the
orthogonal lines $r_{0,3}$ and $r_{3,2}$. $C$ is in the interior of the obstacle representation, i.e., surrounded by the four edges.

\begin{figure}[!h]
\centering
{

%% -------------------POSITION 1----------------------------
\begin{tikzpicture} 
[cube/.style={very thick,black}, 			
grid/.style={very thin,gray},
cube_hidden/.style={very thick,dashed},
polygon/.style={very thick, black},
axis/.style={-,blue,thick},
point/.style={very thick,black}]

\draw[axis] (-.25,2.,0) -- (.5,-1.,0) node[anchor=west,color=blue]{$r_{0,3}$};
\draw[axis] (-1.,0.,0) -- (1.,2.,0) node[anchor=west,color=blue]{$r_{0,1}$};
\draw[axis] (3.75,3.,0) -- (4.375,0.5,0) node[anchor=west,color=blue]{$r_{3,0}$};
%\draw[axis,red] (0.,0.,0) -- (4.25,0.,0) node[anchor=west,color=red]{$s_1$};
%\draw[axis,red] (2.75,-.5,0) -- (4.5,3.,0) node[anchor=west,color=red]{$s_2$};
\draw[axis,red] (5.,2.25,0) -- (-1.,.75,0) node[anchor=east,color=red]{$s_3$};
%\draw[axis,red] (-0.5,1.5,0) -- (1.5,-.5,0) node[anchor=east,color=red]{$s_4$};

\draw[point] (2.0,3.2,0) node[anchor=east]{\textbullet $B$};
\draw[point] (-1.5,2.5,0) node[anchor=east]{\textbullet $A$};
%\draw[axis] (2.0,1.0,0) -- (-0.5,-1.5,0) node[anchor=west,color=blue]{$r_{1,0}$};

\draw[polygon,fill=gray!100] (0,1,0) -- (1,0,0) -- (3,0,0) -- (4,2,0) -- cycle;
\draw[point] (2.6,0.5,0) node[anchor=east]{\textbullet $C$};

\end{tikzpicture}}
\caption{Voronoi regions used for case differentiation. \label{fig:convexpolygon}}
\end{figure}

These cases make use of Voronoi regions~\cite{ericson2004real}. Based on the three types of regions (here we consider the interior of the polygon as a third one) a case differentiation is made and, depending on the case, equations are solved.

It is easy to see that the computation of the point-to-obstacle distance for $A$ is a simple point-to-point distance
using the appropriate vertex. For $B$ a point-to-line distance equation can be used. Finally, since $C$ is in the
interior of the polygon the penetration distance is calculated. It is considered as the shortest of the four distances from the point $C$ to the
four edges multiplied by $-1$ (so, once more, point-to-line distance).

Of course that the performance of this approach is "number of edges"-dependent and present fast results only or 
polygons with few edges (less than 10). \todo[inline, size=\tiny]{10 was arbitrary, improve this finding a meaningful
value or delete it}

An important remark though is that for a given planning horizon $N_{s}$ point-to-obstacle distances have to be calculated. Intuitively we can say that there
is a high probability that most of the $N_{s}$ points are inside the same region defined by theirs relative positions to the obstacle.
Besides, the probability of finding points inside regions that are "far" from the already occupied zones is smaller.
% If not so some of them are likely to be in some adjacent zone and finally they are less likely to be in any other zone.
This heuristic can be used to speed up the planning process by having a smarter initialization of point-to-obstacle distance computation when using a convex polygon representation.

Finally, when dealing with more complex obstacles representations and/or with a more complex representation of the mobile robot geometry the Enhanced Gilbert-Johnson-Keerthi distance algorithm~\cite{ericson2004real} is a more suitable and efficient approach.
\todo[inline]{some code is available on the internet, Google code written in D language and/or the other one on stackoverflow, see bookmarks}


%\begin{figure}[!h]
%	\centering
%	\includegraphics[width=1.\textwidth]{./img/classes_planning.pdf}
%	\caption{Class diagram.\label{fig:classesdiagram}}
%\end{figure}
%\subsection{Analysis of real-time planning feasibility}
%\subsection{Multi-robots}
%Each robot must be able to access the position of any robot of the fleet. If a robot's position cannot be accessed that means the robot lost its connection with the fleet and will not be considered a conflictual robot by none of the others robots.
%Symmetry problem \todo[inline, size=\tiny]{Tc too high no time to avoid another robot involved}
%Gilbert-Johnson-Keerthi distance algorithm

\section{Analysis of the parameters impact on real-time feasibility and solution adequacy}

The performance and solution quality of the motion planning algorithm previously presented depends on several parameters. These parameters can be split into two groups. The \textbf{algorithm related} parameters and the \textbf{optimization solver related} ones. Among the former group, the most important ones are:
\begin{itemize}
\item[$\bullet$] The number of sample for time discretization ($N_s$);
\item[$\bullet$] The number of internal knots for the B-splines curves ($n_{knots}$);
\item[$\bullet$] The planning horizon for the sliding window ($T_p$);
\item[$\bullet$] The computation horizon ($T_c$).
\end{itemize}

The latter kind depends on the optimization solver adopted. However, since most of them are iterative methods, it is common to have at least the two following parameters:
\begin{itemize}
\item[$\bullet$] Maximum number of iterations;
\item[$\bullet$] Stop condition.
\end{itemize}

%The task of searching for a satisfactory set of parameters' values with regard to a performance metric (e.g. total time to complete the miss1ion) is quite laborious.

This high number of parameters having influence on the solution and/or on the time for finding a solution makes the search for a satisfactory set of parameters' values a laborious task.

We attempt nevertheless to extract some quantitative knowledge about how these parameters impact the generated solution and its computation time based on several simulations run with different parameters configurations.
The main objective here is to be able to support the feasibility of a real-time motion planner based on this algorithm.

After these analyses we shall be able to identify sets of parameters' values that minimize the total time spend to complete the mission, respecting the problem constraints
and minimizing the \textit{maximum computation time}/$T_c$ ratio.

\subsection{Computation time analysis}

At first we were interest in finding how variations in $N_s$ and $N_{knots}$ impart the computation time for finding a solution.

Aiming for a scenario invariant understanding of the impact of these parameters three different scenarios were studied. A first scenario where the robot did not had to avoid any obstacle
to complete its mission, a second one where three round obstacles were randomly generated in a region where the robot was probably going to pass through and a third similar to the second
only with six instead of three obstacles.

In addition, to reduce the problem's size, a unique optimization solver with fixed parameters was used for all simulations.
The used parameters can be seen in table~\ref{tab:optparam}. The subscribed words \textit{first}, \textit{inter} and \textit{last} indicate that the respective maximum numbers of iteration are used for the first
optimization problem solving, for all intermediaries ones and for the last one.
Different maximum numbers of iterations are used for different stages of the planning process. This is possible because of two aspects of the problem addressed:
\begin{itemize}
\item[$\bullet$] We assume that the initial configuration at time $t_0$ is static and thus the planning of the first section of the plan does not have to be done within the computation horizon ($T_c$). We choose then to increase the maximum number of iterations for the first planning section in order to achieve better results;
\item[$\bullet$] According to the change in the algorithm for solving the NPL associated with the last section of the plan we know that the last step uses a number of internal knots
($N_{knots}$) smaller than or equal to the number used by the other steps. In the other hand, this final NPL has more constraints than the others NPLs solved before for a given $N_s$.
Since the SLSPQ method requires $O(n^3)$ time to find a solution, where $n$, the dimension of the parameter vector, is directly proportional to the number of internal knots we assume
that the number of maximum iterations for the last step can be increased.

%The NPL solved for last planning section has more constraints then the others NPLs. This alone does not justify giving it a greater maximum number of iterations since the solution still must be found within a $T_c$ horizon. The other factor that allow us to decrease it is that 
\end{itemize}

%\todo[inline]{talk about accuracy}

\begin{table}[!h]
\caption {Optimization solver parameters} \label{tab:optparam}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Optimization solver type & SLSQP\\
\hline
$MAXIT_{first}$ & 40\\
\hline
$MAXIT_{inter}$ & 15\\
\hline
$MAXIT_{last}$ & 20\\
\hline
accuracy & $10^{-3}$\\
\hline
\end{tabular}
\end{center}
\end{table}

Real-time feasibility in this context can be considered as having the \textit{maximum computation time} spend for planning the path sections
\footnote{All computational times spend for planning all sections are considered for finding the maximum value but the first one} less than or equal to the computation horizon ($T_c$).
Here though we are only interest in understanding the variation of \textit{maximum computation time}/$T_c$ with changes in $N_s$ and $N_{knots}$.

%Another natural performance metric that should be kept in mind is the total time spend to complete the mission (going from the initial configuration to the final).

\subsubsection{No obstacles scenario}
%INFO:R0: TOT: 7.16220241525
%INFO:R0: NSE: 14
%INFO:R0: FIR: 0.888309001923
%INFO:R0: LAS: 0.311777114868
%INFO:R0: LMA: 1
%INFO:R0: MAX: 0.0503461360931
%INFO:R0: MIN: 0.0204219818115
%INFO:R0: AVG: 0.0319990317027
%INFO:R0: RMP: 0.125865340233
%INFO:R0: RMG: 0.77944278717

The images in the Figure~\ref{fig:uni0} try to make prominent the effect of changes in the in the number of samples ($N_s$) and number of internal knots ($N_{knots}$). In the ordinate axis we have the \textit{maximum computation time}/$T_c$ ratio and in the abscissa we have the $T_c/T_p$. For each $N_s$ we took the average of the \textit{maximum computation time}/$T_c$ ratio for a give $T_c/T_p$ among different $T_p$ values in order to be $T_p$ invariant.

We can see that for a "no obstacles" scenario the overall performance with respect to the \textit{maximum computation time}/$T_c$ ratio is only slightly impacted by
variations in the number of samples ($N_s$) and in the number of internal knots ($N_{knots}$).
Within a given image the lines are close together showing that variations in $N_s$ have weak impact.
In addition, comparing the three images (\ref{fig:uni04}, \ref{fig:uni05}, \ref{fig:uni06}) we see that variations in the $N_{knots}$ have also a weak influence for this scenario.

\begin{figure}[!h]
        \centering
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_0__N_knots_4/mcttc-tctp.eps}
                \caption{Four internal knots. Average variance between lines is $0.062\times 10^{-2}$}\label{fig:uni04}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_0__N_knots_5/mcttc-tctp.eps}
                \caption{Five internal knots. Average variance between lines is $0.115\times 10^{-2}$}\label{fig:uni05}
        \end{subfigure}%
        
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_0__N_knots_6/mcttc-tctp.eps}
                \caption{Six internal knots. Average variance between lines is $ 0.182\times 10^{-2}$}\label{fig:uni06}
        \end{subfigure}%
        \caption{Zero obstacles scenario.}\label{fig:uni0}
\end{figure}

For the sake of an example we present a simulation result in the Figure~\ref{fig:sim0} run with the parameters presented in the table~\ref{tab:s0param} for a "no obstacles" scenario.

\begin{table}[!h]
\caption {Motion planner main parameters} \label{tab:s0param}
\begin{center}
\begin{tabular}{|c|c|}
\hline
$T_p$ & 2.00 s\\
\hline 
$T_c$ & 0.40 s\\
\hline 
$N_s$ & 9\\
\hline 
$N_{knots}$ & 5\\
\hline
$v_{max}$ & $1.00\ \mathrm{m/s}$\\
\hline
$\omega_{max}$ & $5.00\ \mathrm{rad/s}$\\
\hline
$q_{inital}$ & $[-0.05\ 0.00\ \pi/2]^T$\\
\hline
$q_{final}$ & $[0.10\ 7.00\ \pi/2]^T$\\
\hline
$u_{final}$ & $[0.00\ 0.00]^T$\\
\hline
$u_{final}$ & $[0.00\ 0.00]^T$\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{figure}[!h]
        \centering
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/sim_results/p_0_0.4_2.0_9_5_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0/multirobot-path.png}
                \caption{Robot's path.}\label{fig:sim0rpath}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
		\includegraphics[width=\textwidth]{./img/realtime/sim_results/p_0_0.4_2.0_9_5_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0/multirobot-vw.png}
                \caption{Robot's input.}\label{fig:sim0rinput}
        \end{subfigure}
        \caption{No obstacle scenario simulation example where the \textit{maximum computation time} was about 78\% of $T_c$ and the mission total time equals to $7.16\ s$.}\label{fig:sim0}
\end{figure}
\clearpage
\subsubsection{Three obstacles scenario}
%INFO:R0: TOT: 7.57429378065
%INFO:R0: NSE: 15
%INFO:R0: FIR: 1.07032418251
%INFO:R0: LAS: 0.402824163437
%INFO:R0: LMA: 1
%INFO:R0: MAX: 0.243094921112
%INFO:R0: MIN: 0.0298509597778
%INFO:R0: AVG: 0.156346522845
%INFO:R0: RMP: 0.506447752317
%INFO:R0: RMG: 0.83921700716
%p_3_0.48_2.4_11_4_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0

For this new scenario, a greater impact of the number of samples ($N_s$) and number of non-null internal knots ($N_{knots}$) is observed.
The greater the $N_{knots}$ or the $N_s$ the greater is the \textit{maximum computation time}/$T_c$.
This behavior is the one expected since the number of constraints and the number of arguments for the cost function
to be minimized depend on these two parameters respectively.

\begin{figure}[!h]
        \centering
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_3__N_knots_4/mcttc-tctp.eps}
                \caption{Four internal knots. Average variance between lines is $1.047\times 10^{-2}$}\label{fig:uni34}
        \end{subfigure}
        
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_3__N_knots_5/mcttc-tctp.eps}
                \caption{Five internal knots. Average variance between lines is $0.972\times 10^{-2}$}\label{fig:uni35}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_3__N_knots_6/mcttc-tctp.eps}
                \caption{Six internal knots. Average variance between lines is $0.587\times 10^{-2}$}\label{fig:uni36}
        \end{subfigure}
        \caption{Three obstacles scenario.}\label{fig:uni3}
\end{figure}

Again, in the Figure~\ref{fig:sim0} we show a simulation example run with the parameters' values presented in table~\ref{tab:s3param}.

\begin{table}[!h]
\caption {Motion planner main parameters} \label{tab:s3param}
\begin{center}
\begin{tabular}{|c|c|}
\hline
$T_p$ & 2.40 s\\
\hline 
$T_c$ & 0.48 s\\
\hline 
$N_s$ & 11\\
\hline 
$N_{knots}$ & 4\\
\hline
$v_{max}$ & $1.00\ \mathrm{m/s}$\\
\hline
$\omega_{max}$ & $5.00\ \mathrm{rad/s}$\\
\hline
$q_{inital}$ & $[-0.05\ 0.00\ \pi/2]^T$\\
\hline
$q_{final}$ & $[0.10\ 7.00\ \pi/2]^T$\\
\hline
$u_{final}$ & $[0.00\ 0.00]^T$\\
\hline
$u_{final}$ & $[0.00\ 0.00]^T$\\
\hline
$O_0$ & $[0.55\ 1.91\ 0.31]$\\
\hline
$O_1$ & $[-0.08\ 3.65\ 0.32]$\\
\hline
$O_2$ & $[0.38\ 4.65\ 0.16]$\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{figure}[!h]
        \centering
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/sim_results/p_3_0.48_2.4_11_4_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0/multirobot-path.png}
                \caption{Robot's path.}\label{fig:rpath}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
		\includegraphics[width=\textwidth]{./img/realtime/sim_results/p_3_0.48_2.4_11_4_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0/multirobot-vw.png}
                \caption{Robot's input.}\label{fig:rinput}
        \end{subfigure}
        \caption{Three obstacle scenario simulation example where the \textit{maximum computation time} was about 84\% of $T_c$ and the mission total time equals to $7.57\ s$.}\label{fig:uni3}
\end{figure}
\clearpage
\subsubsection{Six obstacles scenario}

%INFO:R0: TOT: 7.76460065867
%INFO:R0: NSE: 7
%INFO:R0: FIR: 2.3883190155
%INFO:R0: LAS: 0.536874055862
%INFO:R0: LMA: 0
%INFO:R0: MAX: 1.1533639431
%INFO:R0: MIN: 0.116408824921
%INFO:R0: AVG: 0.802022314072
%INFO:R0: RMP: 0.901065580547
%INFO:R0: RMG: 0.901065580547

As for the scenario with six obstacles we realize that the observations for the latest scenario are accentuated.

\begin{figure}[!h]
        \centering
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_6__N_knots_4/mcttc-tctp.eps}
                \caption{Four internal knots.  Average variance between lines is $2.272\times 10^{-2}$}\label{fig:uni64}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_6__N_knots_5/mcttc-tctp.eps}
                \caption{Five internal knots.  Average variance between lines is $2.635\times 10^{-2}$}\label{fig:uni65}
        \end{subfigure}
        
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_6__N_knots_6/mcttc-tctp.eps}
                \caption{Six internal knots.  Average variance between lines is $1.526\times 10^{-2}$}\label{fig:uni66}
        \end{subfigure}
        \caption{Six obstacles scenario.}\label{fig:uni6}
\end{figure}


\begin{table}[!h]
\caption {Motion planner main parameters} \label{tab:s3param}
\begin{center}
\begin{tabular}{|c|c|}
\hline
$T_p$ & 3.20 s\\
\hline 
$T_c$ & 1.28 s\\
\hline 
$N_s$ & 12\\
\hline 
$N_{knots}$ & 6\\
\hline
$v_{max}$ & $1.00\ \mathrm{m/s}$\\
\hline
$\omega_{max}$ & $5.00\ \mathrm{rad/s}$\\
\hline
$q_{inital}$ & $[-0.05\ 0.00\ \pi/2]^T$\\
\hline
$q_{final}$ & $[0.10\ 7.00\ \pi/2]^T$\\
\hline
$u_{final}$ & $[0.00\ 0.00]^T$\\
\hline
$u_{final}$ & $[0.00\ 0.00]^T$\\
\hline
$O_0$ & $[-0.35\ 1.36\ 0.39]$\\
\hline
$O_1$ & $[0.21\ 2.53\ 0.33]$\\
\hline
$O_2$ & $[-0.32\ 4.86\ 0.23]$\\
\hline
$O_3$ & $[0.10\ 3.98\ 0.31]$\\
\hline
$O_4$ & $[0.62\ 1.25\ 0.18]$\\
\hline
$O_5$ & $[1.17\ 3.66\ 0.25]$\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{figure}[!h]
        \centering
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/sim_results/p_6_1.28_3.2_12_6_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0/multirobot-path.png}
                \caption{Robot's path.}\label{fig:rpath}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
		\includegraphics[width=\textwidth]{./img/realtime/sim_results/p_6_1.28_3.2_12_6_0.001_15_40_20_5.0_0.1_3.0_0.5_1.0_10.0/multirobot-vw.png}
                \caption{Robot's input.}\label{fig:rinput}
        \end{subfigure}
        \caption{Six obstacle scenario simulation example where the \textit{maximum computation time} was about 90\% of $T_c$ and the mission total time equals to $7.76\ s$.}\label{fig:uni3}
\end{figure}

\todo[inline]{add compt time X max number of detected obsts}

A deeper analysis showed us that the SLSQP solver requires $O(n^3)$ time for finding the NPL solution, $n$ being the parameters dimension which is directly
proportional to $N_{knots}$. However the solver require $O(N)$ time, $N$ being the constraints dimension which is directly proportional to $N_s$.

Worth noticing though that the complexy orders just presented are specific for this optimization solver. Other solvers presenting different stategies for
solving the NPL will
behave differently. In addition, the number of internal knots tends to be quite small (less than 10) for usual scenarios (TODO: specify what is a usual scenario,
mobile robot linear speed, concentration of obstacles). Finally, increasing $N_{knots}$ does not mean an improvement of the solution adequacy
necessarely (TODO: develop
why, saying that more control points than needed does help).
While an increasing in the sampling number $N_s$ always improve solution adequacy with respect to obstacle penetration as shown in the next section.

\subsection{Detection radius impact}

As the detection radius of the robot increases more obstacles are seen at a time which linearly increases the number of constraints in the NPL.
Figure~\ref{fig:drho-rmg} gives a example of how the ratio varies as the detection radius progressively increases. The numbers that can be seen
over the blue curve are the maximum number of obstacles seen at once during the whole mission.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.6\textwidth]{./img/penetration/drho-rmp.eps}
	\caption{$MCT/T_c$ ratio varying with $\rho_d$.\label{fig:drho-rmg}}
\end{figure}

\clearpage
\subsection{Solution adequacy}

The time spend for finding the solution for a given set of
parameters values does not impact the solution itself.
Let's analyze then how the solution behaves according to some parameters.

Two important notions when trying to quantify the adequacy of the solution are the total time spend for completing the mission and some metric about how
much the planned path avoids obstacles.

\subsubsection{Total mission time}

Figure~\ref{fig:ttot} show how the time spend for completing the mission behaves with respect to three parameters: $T_c$, $T_p$, $N_s$.

\begin{figure}[!h]
        \centering
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_3__N_knots_6/tot10.eps}
                \caption{$N_s = 10$}\label{fig:ttot1}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_3__N_knots_6/tot11.eps}
                \caption{$N_s = 11$}\label{fig:ttot2}
        \end{subfigure}
        
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.48\textwidth}
                \includegraphics[width=\textwidth]{./img/realtime/Scenario_3__N_knots_6/tot12.eps}
                \caption{$N_s = 12$}\label{fig:ttot3}
        \end{subfigure}
        \caption{Variation of total mission time with the computation horizon ($T_c$) for differet planning horizons ($T_p$) and $N_s$ and three obstacles.}\label{fig:ttot}
\end{figure}

%Due to the discretization and 
We observe an overall tendency that for a given number of internal knots and $N_s$ the total mission decreases as the planning horizon decreases.
This can be explained by the fact that the trajectory quality (optimality) is degradated as the density of internal knots $N_{knots}$ within a $T_p$ decreases
too much.

One may notice as well that the total mission time is invariant with respect to $T_c$ in the sense that no pattern can be observed besides
oscillations of the total time due to the scenario specific configuration.

Another relevant observation is that the overall time for completing the mission decreases as the sampling number $N_s$ decreases.
This misleading improvement in the solution adequacy hides the fact that the fewer the samples the greater will be the obstacle penetration as shwon later in this section.

\paragraph{Detection radius} 
We can also be interest in considering how the total mission time changes as the detection radius of the robot increases. In Figure~\ref{fig:drho-tot} we see the
rapidly decrease of the the mission time as the $\rho_d$ increases showing that a more optimal trajectory can be found when a better knologde of the environment is
possible.

\begin{figure}[!h]
	\centering
	\includegraphics[width=.6\textwidth]{./img/penetration/drho-tot.eps}
	\caption{Total mission time varying with $\rho_d$.\label{fig:drho-tot}}
\end{figure}

\todo[inline]{Get no obstacles information too}

\clearpage
\subsubsection{Obstacle penetration}

Rather than using a metric for obstacle avoidance we used its conterpart called here obstacle penetration.
The total obstacle penetration area ($\mathrm{P}$) can be calculated as the some of all the penetration areas ($\mathrm{P}_w$), each one 
being the penetration area found for a given planning section $w$.
$\mathrm{P}_w$ for a round obstacle can be estimated as follows:

\[
\mathrm{P}_w \simeq \frac{T_c}{N_{Tc}} \sum _{o=0}^{M-1} \sum_{k=0}^{N_{Tc}} \frac{r_op_k - \frac{p_k^2}{2}}{r_o-p_k} v_k
\]
where $r_o$ is the radius of the o\textit{th} obstacle, $p_k$ is the length of the penetration and $v_k$ is the linear velocity for a given time instant $k$ within the computing horizon $w$.

As expected, the greater the $N_{ssol}$ (which in turn increases $N_{Tc}$) the more accurate is the area found. We show in Figure \ref{fig:pen-conv} that the area value converges to the precise area as $N_{ssol}$ increases.

 \begin{figure}[!h]
 	\centering
 	\includegraphics[width=.6\textwidth]{./img/penetration/pen-nssol.eps}
 	\caption{Convergence of the area computation.\label{fig:pen-conv}}
 \end{figure}

After some tests we saw that a good estimate for the penetration area can be found using $N_{ssol} > 10N_s$.

Ideally we would have $\mathrm{P}_w = 0$. A way of guarantying that would be to increase the obstacles radius computed by the robot's perception
system by the maximum distance that the robot can run within the time spam $T_p/N_s$ (equivalent to $T_c/N_{T_c}$). However simple, this approach
represents a loss of optimality and will not be considered in this work.

\paragraph{Influence of $N_s$ on penetration area} \mbox{}\\

As state before in subsection or section TODO the sampling was a sensible parameter regarding the computation time.
The greater the number of samples the greater the number of inquations constraints and consequently the computation time for solving the NLP.
Now, analyzing the impact of the sampling on the penetration area we see that the greater the number of samples the smaller is the penetration area (as expected).
In Figure \ref{fig:ns-pen} we see that the penetration total area rapidly decreases as $N_s$ increases.

 \begin{figure}[!h]
 	\centering
 	\includegraphics[width=.6\textwidth]{./img/penetration/pen-nsi.eps}
 	\caption{Penetration area varying with $N_s$.\label{fig:ns-pen}}
 \end{figure}

 
\subsection{Conclusions}

\begin{itemize}
 \item [$\bullet$] $MCT/T_c$ is $O(n^3)$ where $n$ is directly proportional to $N_{knots}$;
 \item [$\bullet$] $MCT/T_c$ is $O(n)$ where $n$ is directly proportional to $N_s$;
 \item [$\bullet$] $T_{tot}$ decreases as $N_s$ decreases (up to a minimum value);
 \item [$\bullet$] $T_{tot}$ is not influenced by $T_c$ in a observable way;
 \item [$\bullet$] $T_{tot}$ decreases as the $N_{knots}$ increases;$
 \item [$\bullet$] $P$ increases as $N_s$ decreases (up to a maximum value);
 \item [$\bullet$] $T_{tot}$ is $~O(n)$ where $n$ is $N_s$;
\end{itemize}


%A planning horizon can make the optimization problem more expensive and since more obstacles will be taken into account within one planning section. This may explain the fact that for a given optimization solver configuration (same accuracy and same maximum number of iterations) and a given computing horizon the total time to complete the mission is greater then for some smaller planning horizons.
%
%Besides, since no acceleration constraints were take into account really small.


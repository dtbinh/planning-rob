% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Motion Planning Documentation}
\date{May 18, 2015}
\release{1.0}
\author{Jos√© MENDES}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{\texttt{planning\_sim} --- Motion planning simulation}
\label{Multi-robot motion planner:planning-sim-motion-planning-simulation}\label{Multi-robot motion planner::doc}\label{Multi-robot motion planner:logo-welcome-to-motion-planning-s-documentation}\label{Multi-robot motion planner:module-planning_sim}\index{planning\_sim (module)}
The {\hyperref[Multi-robot motion planner:module-planning_sim]{\code{planning\_sim}}} module implements classes to simulate a navigation
scenario consisting of one or more mobile robots that autonomously plan their
motion from an initial state to a final state avoiding static obstacles and
other robots, and respecting kinematic (including nonhonolonomic) constraints.

The motion planner is based on the experimental work developed by Michael Defoort
that seeks a near-optimal solution minimizing the time spend by a robot to
complete its mission.


\section{Obstacles and Boundary}
\label{Multi-robot motion planner:obstacles-and-boundary}

\bigskip\hrule{}\bigskip

\index{Obstacle (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Obstacle}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{Obstacle}}{\emph{position}}{}
Bases: \href{http://docs.python.org/library/functions.html\#object}{\code{object}}

Base class for implementing simulated obstacles.
\begin{description}
\item[{Input}] \leavevmode
\emph{position}: array-like type representing the obstacle's position (x,y).

\end{description}
\index{detected\_dist() (planning\_sim.Obstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Obstacle.detected_dist}\pysiglinewithargsret{\bfcode{detected\_dist}}{\emph{pt}}{}
Return the detected distance of this obstacle as seen by a robot at the position pt
(as a float).

\end{fulllineitems}

\index{pt\_2\_obst() (planning\_sim.Obstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Obstacle.pt_2_obst}\pysiglinewithargsret{\bfcode{pt\_2\_obst}}{\emph{pt}, \emph{offset=0.0}}{}
Return the point-to-obstacle distance less the offset value (as a float).

\end{fulllineitems}

\index{centroid (planning\_sim.Obstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Obstacle.centroid}\pysigline{\bfcode{centroid}\strong{ = None}}
Obstacle's centroid. Considered here the obstacle given position.

\end{fulllineitems}


\end{fulllineitems}



\bigskip\hrule{}\bigskip

\index{RoundObstacle (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{RoundObstacle}}{\emph{position}, \emph{radius}}{}
Bases: {\hyperref[Multi-robot motion planner:planning_sim.Obstacle]{\code{planning\_sim.Obstacle}}}

Representation of an obstacle as a circle.
\index{\_plt\_circle() (planning\_sim.RoundObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle._plt_circle}\pysiglinewithargsret{\bfcode{\_plt\_circle}}{\emph{color='k'}, \emph{linestyle='solid'}, \emph{filled=False}, \emph{alpha=1.0}, \emph{offset=0.0}}{}
Return a \href{http://matplotlib.org/api/patches\_api.html\#matplotlib.patches.Circle}{Circle} object representing the obstacle
geometry.

\end{fulllineitems}

\index{detected\_dist() (planning\_sim.RoundObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle.detected_dist}\pysiglinewithargsret{\bfcode{detected\_dist}}{\emph{pt}}{}
Return the detected distance of this obstacle as seen by a robot at the position pt
(as a float).

\end{fulllineitems}

\index{plot() (planning\_sim.RoundObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle.plot}\pysiglinewithargsret{\bfcode{plot}}{\emph{fig}, \emph{offset=0.0}}{}
Given a figure this method gets its active axes and plots a grey circle representing
the obstacle as well as a second, concentric, dashed circle having the original circle
radius plus the offset value as its own radius.

\end{fulllineitems}

\index{pt\_2\_obst() (planning\_sim.RoundObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle.pt_2_obst}\pysiglinewithargsret{\bfcode{pt\_2\_obst}}{\emph{pt}, \emph{offset=0.0}}{}
Return the point-to-obstacle distance less the offset value
and less the obstacle radius (as a float).

\end{fulllineitems}

\index{radius (planning\_sim.RoundObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle.radius}\pysigline{\bfcode{radius}\strong{ = None}}
Obstacle radius.

\end{fulllineitems}

\index{x (planning\_sim.RoundObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle.x}\pysigline{\bfcode{x}\strong{ = None}}
x-coordinate of the obstacle centroid.

\end{fulllineitems}

\index{y (planning\_sim.RoundObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RoundObstacle.y}\pysigline{\bfcode{y}\strong{ = None}}
y-coordinate of the obstacle centroid.

\end{fulllineitems}


\end{fulllineitems}



\bigskip\hrule{}\bigskip

\index{PolygonObstacle (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{PolygonObstacle}}{\emph{vertices}}{}
Bases: {\hyperref[Multi-robot motion planner:planning_sim.Obstacle]{\code{planning\_sim.Obstacle}}}
\index{\_calculate\_polygon\_area() (planning\_sim.PolygonObstacle static method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle._calculate_polygon_area}\pysiglinewithargsret{\strong{static }\bfcode{\_calculate\_polygon\_area}}{\emph{polygon}, \emph{signed=False}}{}
Calculate the signed area of non-self-intersecting polygon
\begin{description}
\item[{Input}] \leavevmode\begin{description}
\item[{\emph{polygon}: Numeric array of points (longitude, latitude). It is assumed}] \leavevmode
to be closed, i.e. first and last points are identical

\item[{\emph{signed}: Optional flag deciding whether returned area retains its sign:}] \leavevmode
If points are ordered counter clockwise, the signed area
will be positive.
If points are ordered clockwise, it will be negative
Default is False which means that the area is always positive.

\end{description}

\item[{Output}] \leavevmode
Area of polygon (subject to the value of argument signed)

\end{description}

\end{fulllineitems}

\index{\_calculate\_polygon\_centroid() (planning\_sim.PolygonObstacle static method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle._calculate_polygon_centroid}\pysiglinewithargsret{\strong{static }\bfcode{\_calculate\_polygon\_centroid}}{\emph{polygon}}{}
Calculate the centroid of non-self-intersecting polygon
\begin{description}
\item[{Input}] \leavevmode
\emph{polygon}: Numeric array of points (longitude, latitude). It is assumed
to be closed, i.e. first and last points are identical

\item[{Output}] \leavevmode
Numeric (1 x 2) array of points representing the centroid

\end{description}

\end{fulllineitems}

\index{\_create\_aug\_vertices() (planning\_sim.PolygonObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle._create_aug_vertices}\pysiglinewithargsret{\bfcode{\_create\_aug\_vertices}}{\emph{offset}}{}
Create augmented vertices from original vertices and offset value
\begin{description}
\item[{Input}] \leavevmode
\emph{offset}: Real value used as offset from original vertices. Can also
be seen as the radius of the circle that will be subtracted (in the
Minkowski difference sense) from the obstacle geometry.

\end{description}

\end{fulllineitems}

\index{detected\_dist() (planning\_sim.PolygonObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.detected_dist}\pysiglinewithargsret{\bfcode{detected\_dist}}{\emph{pt}}{}
Return the detected distance of this obstacle as seen by a robot at the position pt
(as a float).

\end{fulllineitems}

\index{plot() (planning\_sim.PolygonObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.plot}\pysiglinewithargsret{\bfcode{plot}}{\emph{fig}, \emph{offset=0.0}}{}
Given a figure this method gets its active axes and plots a grey polygon representing
the obstacle as well as some dashed lines associated with the Minkowski difference of
the obstacle representation and a circle of radius equals to offset.

\end{fulllineitems}

\index{pt\_2\_obst() (planning\_sim.PolygonObstacle method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.pt_2_obst}\pysiglinewithargsret{\bfcode{pt\_2\_obst}}{\emph{pt}, \emph{offset=0.0}}{}
Calculate distance from point to the obstacle
\begin{description}
\item[{Input}] \leavevmode
\emph{pt}: cardinal coordinates of the point

\emph{offset}: offset distance that will be subtracted from the actual
point-to-obstacle distance

\item[{Output}] \leavevmode
Real number representing the distance pt\_2\_obstacle less offset. Negative value means
that the point is closer then the offset value from the obstacle, or even inside it.

\end{description}

\begin{notice}{note}{Todo}

Fix error handling
\end{notice}

\end{fulllineitems}

\index{bounding\_circle\_radius (planning\_sim.PolygonObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.bounding_circle_radius}\pysigline{\bfcode{bounding\_circle\_radius}\strong{ = None}}
Compute the radius of a bounding circle for the obstacle centred on the centroid.

\begin{notice}{warning}{Warning:}
This is not necessarily the smaller bounding circle. It would be better to
get the the midpoint of the greatest line segment formed by two of the
polygons vertices as the circle center and half of the that line segment
as its radius.
\end{notice}

\end{fulllineitems}

\index{centroid (planning\_sim.PolygonObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.centroid}\pysigline{\bfcode{centroid}\strong{ = None}}
Obstacle's centroid

\end{fulllineitems}

\index{x (planning\_sim.PolygonObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.x}\pysigline{\bfcode{x}\strong{ = None}}
x-coordinate of the obstacle centroid.

\end{fulllineitems}

\index{y (planning\_sim.PolygonObstacle attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.PolygonObstacle.y}\pysigline{\bfcode{y}\strong{ = None}}
y-coordinate of the obstacle centroid.

\end{fulllineitems}


\end{fulllineitems}



\bigskip\hrule{}\bigskip

\index{Boundary (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Boundary}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{Boundary}}{\emph{x}, \emph{y}}{}
Bases: \href{http://docs.python.org/library/functions.html\#object}{\code{object}}
\index{x\_max (planning\_sim.Boundary attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Boundary.x_max}\pysigline{\bfcode{x\_max}\strong{ = None}}
Max bound in the x direction.

\end{fulllineitems}

\index{x\_min (planning\_sim.Boundary attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Boundary.x_min}\pysigline{\bfcode{x\_min}\strong{ = None}}
Min bound in the x direction.

\end{fulllineitems}

\index{y\_max (planning\_sim.Boundary attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Boundary.y_max}\pysigline{\bfcode{y\_max}\strong{ = None}}
Max bound on y direction.

\end{fulllineitems}

\index{y\_min (planning\_sim.Boundary attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Boundary.y_min}\pysigline{\bfcode{y\_min}\strong{ = None}}
Min bound in the y direction.

\end{fulllineitems}


\end{fulllineitems}



\section{Robot and Kinematic Model}
\label{Multi-robot motion planner:robot-and-kinematic-model}

\bigskip\hrule{}\bigskip

\index{UnicycleKineModel (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{UnicycleKineModel}}{\emph{q\_init, q\_final, u\_init={[}0.0, 0.0{]}, u\_final={[}0.0, 0.0{]}, u\_max={[}1.0, 5.0{]}, a\_max={[}2.0, 10.0{]}}}{}
Bases: \href{http://docs.python.org/library/functions.html\#object}{\code{object}}

This class defines the kinematic model of an unicycle mobile robot.

Unicycle kinematic model:
\begin{gather}
\begin{split}\begin{array}{c}
\dot{q} = \mathrm{f}(q, u) \Rightarrow\\
\left[\begin{array}{c}
\dot{x}\\
\dot{y}\\
\dot{\theta}
\end{array}\right]=
\left[\begin{array}{c}
v\cos(\theta)\\
v\sin(\theta)\\
w
\end{array}\right]
\end{array}\end{split}\notag
\end{gather}
Changing variables (\(z = [x, y]^T\)) we can rewrite the system using the
flat output \(z\) as:
\begin{gather}
\begin{split}\left[\begin{array}{c}
x\\
y\\
\theta\\
v\\
w
\end{array}\right]=
\left[\begin{array}{c}
z_1\\
z_2\\
\arctan(\dot{z}_2/\dot{z}_1)\\
\sqrt{\dot{z}_{1}^{2} + \dot{z}_{2}^{2}}\\
\dfrac{\dot{z}_{1}\ddot{z}_{2} - \dot{z}_{2}\ddot{z}_{1}}{\dot{z}_{1}^{2}+\dot{z}_{2}^{2}}
\end{array}\right]\end{split}\notag
\end{gather}
where the the state and input vector (\(q, v\)) are function of \(z\)
and its derivatives.
\index{\_unsigned\_angle() (planning\_sim.UnicycleKineModel static method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel._unsigned_angle}\pysiglinewithargsret{\strong{static }\bfcode{\_unsigned\_angle}}{\emph{angle}}{}
Map signed angles (\(\theta \in (-\pi, \pi]\)) to unsigned
(\(\theta \in [0, 2\pi)\)).

\begin{notice}{note}{Note:}
Method not used.
\end{notice}

\end{fulllineitems}

\index{phi\_0() (planning\_sim.UnicycleKineModel method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.phi_0}\pysiglinewithargsret{\bfcode{phi\_0}}{\emph{q}}{}
Returns \(z\) given \(q\)

\end{fulllineitems}

\index{phi\_1() (planning\_sim.UnicycleKineModel method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.phi_1}\pysiglinewithargsret{\bfcode{phi\_1}}{\emph{zl}}{}
Returns \([x\ y\ \theta]^T\) given \([z\ \dot{z}\ \dotsc\ z^{(l)}]\)
(only \(z\) and \(\dot{z}\) are used). \(\theta\) is in the range
\((-\pi, \pi]\).
\begin{gather}
\begin{split}\begin{array}{l}
\varphi_1(z(t_k),\dotsc,z^{(l)}(t_k))=\
\left[\begin{array}{c}
x\\
y\\
\omega
\end{array}\right]
\left[\begin{array}{c}
z_1\\
z_2\\
\arctan(\dot{z}_2/\dot{z}_1)\\
\end{array}\right]
\end{array}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{phi\_2() (planning\_sim.UnicycleKineModel method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.phi_2}\pysiglinewithargsret{\bfcode{phi\_2}}{\emph{zl}}{}
Returns \([v\ \omega]^T\) given \([z\ \dot{z}\ \dotsc\ z^{(l)}]\)
(only \(\dot{z}\) and \(\ddot{z}\) are used).
\begin{gather}
\begin{split}\begin{array}{l}
\varphi_2(z(t_k),\dotsc,z^{(l)}(t_k))=\
\left[\begin{array}{c}
v\\
\omega
\end{array}\right]
= \left[\begin{array}{c}
\sqrt{\dot{z}_{1}^{2} + \dot{z}_{2}^{2}}\\
\dfrac{\dot{z}_{1}\ddot{z}_{2} -
\dot{z}_{2}\ddot{z}_{1}}{\dot{z}_{1}^{2}+\dot{z}_{2}^{2}}
\end{array}\right]
\end{array}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{phi\_3() (planning\_sim.UnicycleKineModel method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.phi_3}\pysiglinewithargsret{\bfcode{phi\_3}}{\emph{zl}}{}
Returns \([\dot{v}\ \dot{\omega}]^T\) given
\([z\ \dot{z}\ \dotsc\ z^{(l+1)}]\).
(only \(\dot{z}\), \(\ddot{z}\) and \(z^{(3)}\) are used).
\begin{gather}
\begin{split}\begin{array}{l}
\varphi_3(z(t_k),\dotsc,z^{(l+1)}(t_k))=\
\left[\begin{array}{c}
\dot{v}\\
\dot{\omega}
\end{array}\right]
= \left[\begin{array}{c}
\frac{\partial}{\partial t}v\\
\frac{\partial}{\partial t}\omega
\end{array}\right]
= \left[\begin{array}{c}
\frac{\dot{z}_1\ddot{z}_1 + \dot{z}_2\ddot{z}_2}{\|\dot{z}\|}\\
\frac{(\ddot{z}_1\ddot{z}_2+ z^{(3)}_2\dot{z}_1 -
(\ddot{z}_2\ddot{z}_1+z^{(3)}_1\dot{z}_2))\|\dot{z}\|^2-
2(\dot{z}_1\ddot{z}_2-\dot{z}_2\ddot{z}_1)\|\dot{z}\|\dot{v}}{\|\dot{z}\|^4}
\end{array}\right]
\end{array}\end{split}\notag
\end{gather}
\end{fulllineitems}

\index{acc\_max (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.acc_max}\pysigline{\bfcode{acc\_max}\strong{ = None}}
Absolute maximum values for the first derivative of the input vector.

\begin{notice}{note}{Note:}
Value not used.
\end{notice}

\end{fulllineitems}

\index{l (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.l}\pysigline{\bfcode{l}\strong{ = None}}
Number of flat output derivatives that are needed to calculate the state
and input vectors.

\end{fulllineitems}

\index{q\_dim (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.q_dim}\pysigline{\bfcode{q\_dim}\strong{ = None}}
State vector order.

\end{fulllineitems}

\index{q\_final (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.q_final}\pysigline{\bfcode{q\_final}\strong{ = None}}
Final state.

\end{fulllineitems}

\index{q\_init (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.q_init}\pysigline{\bfcode{q\_init}\strong{ = None}}
Initial state.

\end{fulllineitems}

\index{u\_dim (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.u_dim}\pysigline{\bfcode{u\_dim}\strong{ = None}}
Input vector order.

\end{fulllineitems}

\index{u\_final (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.u_final}\pysigline{\bfcode{u\_final}\strong{ = None}}
Final input.

\end{fulllineitems}

\index{u\_init (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.u_init}\pysigline{\bfcode{u\_init}\strong{ = None}}
Initial input.

\end{fulllineitems}

\index{u\_max (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.u_max}\pysigline{\bfcode{u\_max}\strong{ = None}}
Absolute max input.

\end{fulllineitems}

\index{z\_dim (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.z_dim}\pysigline{\bfcode{z\_dim}\strong{ = None}}
Flat output vector order.

\end{fulllineitems}

\index{z\_final (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.z_final}\pysigline{\bfcode{z\_final}\strong{ = None}}
Final flat output.

\end{fulllineitems}

\index{z\_init (planning\_sim.UnicycleKineModel attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.UnicycleKineModel.z_init}\pysigline{\bfcode{z\_init}\strong{ = None}}
Initial flat output.

\end{fulllineitems}


\end{fulllineitems}



\bigskip\hrule{}\bigskip

\index{Robot (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{Robot}}{\emph{eyed}, \emph{kine\_model}, \emph{obstacles}, \emph{phy\_boundary}, \emph{neigh}, \emph{N\_s=20}, \emph{n\_knots=6}, \emph{t\_init=0.0}, \emph{t\_sup=10000000000.0}, \emph{Tc=1.0}, \emph{Tp=3.0}, \emph{Td=3.0}, \emph{rho=0.2}, \emph{detec\_rho=3.0}, \emph{com\_range=15.0}, \emph{def\_epsilon=0.5}, \emph{safe\_epsilon=0.1}, \emph{ls\_time\_opt\_scale=1.0}, \emph{dist\_opt\_offset=100.0}, \emph{ls\_min\_dist=0.5}}{}
Bases: \href{http://docs.python.org/library/functions.html\#object}{\code{object}}

Class for creating a robot in the simulation.
It implements the Defoort's experimental motion planning algorithm
\index{\_co\_criterion() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._co_criterion}\pysiglinewithargsret{\bfcode{\_co\_criterion}}{\emph{x}}{}
Cost function to be minimized used for optimizing
the first and intermediaries sections of the plan when conflicts are detected.
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Cost value.

\end{description}

\begin{notice}{warning}{Warning:}
Optimization solver can misbehave for costs too big (\(> 10^{6}\)).
\end{notice}

\begin{notice}{note}{Note:}
This method is just a call to the {\hyperref[Multi-robot motion planner:planning_sim.Robot._sa_criterion]{\code{\_sa\_criterion()}}} method.
\end{notice}

\end{fulllineitems}

\index{\_co\_feqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._co_feqcons}\pysiglinewithargsret{\bfcode{\_co\_feqcons}}{\emph{x}}{}
Calculate the \textbf{equations} constraints values for the first and intermadiaries
section of the plan when there are conflicts.
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the equations' values.

\end{description}

\begin{notice}{note}{Note:}
This method is just a call to the {\hyperref[Multi-robot motion planner:planning_sim.Robot._sa_feqcons]{\code{\_sa\_feqcons()}}} method.
\end{notice}

\end{fulllineitems}

\index{\_co\_fieqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._co_fieqcons}\pysiglinewithargsret{\bfcode{\_co\_fieqcons}}{\emph{x}}{}
Calculate the \textbf{inequations} constraints values for the first and intermadiaries
section of the plan when there are conflicts.

The following expressions are evaluated:
\begin{gather}
\begin{split}\left\lbrace\begin{array}{lcl}
u_{max} - |\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\
u_{max} - |\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\
\dotsc\\
u_{max} - |\varphi_2(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec}))|\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-1,\ sec}),
\dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-1,\ sec}),
\dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),
\dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),
\dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-1,\ sec}),
\dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_{M-1})\\
\mathrm{collision()}\\
\mathrm{communication()}\\
\mathrm{deviation()}
\end{array}\right.\end{split}\notag
\end{gather}\begin{description}
\item[{where:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\(sec\)
 & 
indicates the current plan section.
\\
\hline
\(O_i\)
 & 
is the ith detected obstacle.
\\
\hline
\(M\)
 & 
is the number of detected obstacles.
\\
\hline
\(N_s\)
 & 
is the number of time samples for a plan section.
\\
\hline\end{tabulary}


\end{description}

\begin{notice}{note}{Todo}

Add the expression for collision, communication and deviation constraints.
\end{notice}
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the inequations' values.

\end{description}

\end{fulllineitems}

\index{\_comb\_bsp() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._comb_bsp}\pysiglinewithargsret{\bfcode{\_comb\_bsp}}{\emph{t}, \emph{ctrl\_pts}, \emph{deriv\_order}}{}
Combine base b-splines into a Bezier curve given control points and derivate order.
\begin{description}
\item[{Input}] \leavevmode
\emph{ctrl\_pts}: numpy array with dimension \(n\times m\) n being the number of
the control points and m flat output dimension.

\emph{deriv\_order}: derivative order of the Bezier curve.

\emph{t}: discrete time array.

\item[{Return}] \leavevmode
\(m\times p\) numpy array representing the resulting Bezier curve, m being
the flat output dimension and p the discrete time array dimension.

\end{description}

\end{fulllineitems}

\index{\_compute\_conflicts() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._compute_conflicts}\pysiglinewithargsret{\bfcode{\_compute\_conflicts}}{}{}
Determine the list of conflictous robots among all other robots.
This method updates the \code{\_conflict\_robots\_idx} private attribute.

\end{fulllineitems}

\index{\_detect\_obst() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._detect_obst}\pysiglinewithargsret{\bfcode{\_detect\_obst}}{}{}
Determinate which obstacles are within the detection radius.
This method updates the \code{\_detected\_obst\_idxs}
private attribute.

\end{fulllineitems}

\index{\_gen\_knots() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._gen_knots}\pysiglinewithargsret{\bfcode{\_gen\_knots}}{\emph{t\_init}, \emph{t\_final}}{}
Generate b-spline knots given initial and final times.

\end{fulllineitems}

\index{\_log() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._log}\pysiglinewithargsret{\bfcode{\_log}}{\emph{logid}, \emph{strg}}{}
Log writer (multiprocess safe).
\begin{description}
\item[{Input}] \leavevmode\begin{description}
\item[{\emph{logid}:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

`d'
 & 
for debug
\\
\hline
`i'
 & 
for information
\\
\hline
`w'
 & 
for warning
\\
\hline
`e'
 & 
for error
\\
\hline
`c'
 & 
for critical
\\
\hline\end{tabulary}


\end{description}

\emph{strg}: log string.

\end{description}

\end{fulllineitems}

\index{\_ls\_co\_criterion() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._ls_co_criterion}\pysiglinewithargsret{\bfcode{\_ls\_co\_criterion}}{\emph{x}}{}
Cost function to be minimized used for optimizing
the last section of the plan when conflicts are detected.
It calculates the square of the total plan time.
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Cost value.

\end{description}

\begin{notice}{warning}{Warning:}
Optimization solver can misbehave for costs too big (\(> 10^{6}\)).
\end{notice}

\begin{notice}{note}{Note:}
This method is just a call to the {\hyperref[Multi-robot motion planner:planning_sim.Robot._ls_sa_criterion]{\code{\_ls\_sa\_criterion()}}} method.
\end{notice}

\end{fulllineitems}

\index{\_ls\_co\_feqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._ls_co_feqcons}\pysiglinewithargsret{\bfcode{\_ls\_co\_feqcons}}{\emph{x}}{}
Calculate the \textbf{equations} constraints values for the last section of the plan when
there are conflicts.
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the equations' values.

\end{description}

\begin{notice}{note}{Note:}
This method is just a call to the {\hyperref[Multi-robot motion planner:planning_sim.Robot._ls_co_criterion]{\code{\_ls\_co\_criterion()}}} method.
\end{notice}

\end{fulllineitems}

\index{\_ls\_co\_fieqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._ls_co_fieqcons}\pysiglinewithargsret{\bfcode{\_ls\_co\_fieqcons}}{\emph{x}}{}
Calculate the \textbf{inequations} constraints values for the last section of the plan when
there are conflicts.

The following expressions are evaluated:
\begin{gather}
\begin{split}\left\lbrace\begin{array}{lcl}
u_{max} - |\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\
u_{max} - |\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\
\dotsc\\
u_{max} - |\varphi_2(z(t_{N_s-2,\ sec}),\dotsc,z^{(l)}(t_{N_s-2,\ sec}))|\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-2,\ sec}),
\dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-2,\ sec}),
\dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),
\dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),
\dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-2,\ sec}),
\dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_{M-1})\\
\end{array}\right.\end{split}\notag
\end{gather}\begin{description}
\item[{where:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\(sec\)
 & 
indicates the current plan section.
\\
\hline
\(O_i\)
 & 
is the ith detected obstacle.
\\
\hline
\(M\)
 & 
is the number of detected obstacles.
\\
\hline
\(N_s\)
 & 
is the number of time samples for a plan section.
\\
\hline\end{tabulary}


\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the inequations' values.

\end{description}

\begin{notice}{note}{Todo}

Take into account the coflict constraints!
The way it is this method is identical to the {\hyperref[Multi-robot motion planner:planning_sim.Robot._ls_sa_fieqcons]{\code{\_ls\_sa\_fieqcons()}}} method,
which is pretty bad.
\end{notice}

\end{fulllineitems}

\index{\_ls\_sa\_criterion() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._ls_sa_criterion}\pysiglinewithargsret{\bfcode{\_ls\_sa\_criterion}}{\emph{x}}{}
Cost function to be minimized used for optimizing
the last section of the plan when no conflicts are detected.
It calculates the square of the total plan time.
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Cost value.

\end{description}

\begin{notice}{warning}{Warning:}
Optimization solver can misbehave for costs too big (\(> 10^{6}\)).
\end{notice}

\end{fulllineitems}

\index{\_ls\_sa\_feqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._ls_sa_feqcons}\pysiglinewithargsret{\bfcode{\_ls\_sa\_feqcons}}{\emph{x}}{}
Calculate the \textbf{equations} constraints values for the last section of the plan when
there are no conflicts.

The following expressions are evaluated:
\begin{gather}
\begin{split}\left\lbrace\begin{array}{lcl}
\varphi_1(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))
&-& q_{N_s-1,\ sec-1}\\
\varphi_1(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec}))
&-& q_{final}\\
\varphi_2(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))
&-&u_{N_s-1,\ sec-1}\\
\varphi_2(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec})) &-& u_{final}\\
\end{array}\right.\end{split}\notag
\end{gather}\begin{description}
\item[{where:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\(sec\)
 & 
indicates the current plan section.
\\
\hline\end{tabulary}


\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the equations' values.

\end{description}

\end{fulllineitems}

\index{\_ls\_sa\_fieqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._ls_sa_fieqcons}\pysiglinewithargsret{\bfcode{\_ls\_sa\_fieqcons}}{\emph{x}}{}
Calculate the \textbf{inequations} constraints values for the last section of the plan when
there are no conflicts.

The following expressions are evaluated:
\begin{gather}
\begin{split}\left\lbrace\begin{array}{lcl}
u_{max} - |\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\
u_{max} - |\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\
\dotsc\\
u_{max} - |\varphi_2(z(t_{N_s-2,\ sec}),\dotsc,z^{(l)}(t_{N_s-2,\ sec}))|\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-2,\ sec}),
\dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-2,\ sec}),
\dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),
\dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),
\dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-2,\ sec}),
\dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_{M-1})\\
\end{array}\right.\end{split}\notag
\end{gather}\begin{description}
\item[{where:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\(sec\)
 & 
indicates the current plan section.
\\
\hline
\(O_i\)
 & 
is the ith detected obstacle.
\\
\hline
\(M\)
 & 
is the number of detected obstacles.
\\
\hline
\(N_s\)
 & 
is the number of time samples for a plan section.
\\
\hline\end{tabulary}


\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the inequations' values.

\end{description}

\end{fulllineitems}

\index{\_plan() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._plan}\pysiglinewithargsret{\bfcode{\_plan}}{}{}
Motion/path planner method. At the end of its execution {\hyperref[Multi-robot motion planner:planning_sim.Robot.rtime]{\code{rtime}}}, {\hyperref[Multi-robot motion planner:planning_sim.Robot.ctime]{\code{ctime}}}
and {\hyperref[Multi-robot motion planner:planning_sim.Robot.sol]{\code{sol}}} attributes will be updated with the plan for completing the mission.

\end{fulllineitems}

\index{\_plan\_section() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._plan_section}\pysiglinewithargsret{\bfcode{\_plan\_section}}{}{}
This method takes care of planning a section of the final path over a \(T_{d/p}\)
time horizon.

It also performs syncronization and data exchange among the robots.

\end{fulllineitems}

\index{\_sa\_criterion() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._sa_criterion}\pysiglinewithargsret{\bfcode{\_sa\_criterion}}{\emph{x}}{}
Cost function to be minimized used for optimizing
the first and intermediaries sections of the plan when no conflicts are detected.

It calculates the distance between the final position of the proposed plan and
the \emph{goal point}.

The \emph{goal point} is calcualted as follows:

\begin{notice}{note}{Todo}

Add the expression for computing the goal point.
\end{notice}
\begin{description}
\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Cost value.

\end{description}

\begin{notice}{warning}{Warning:}
Optimization solver can misbehave for costs too big (\(> 10^{6}\)).
\end{notice}

\end{fulllineitems}

\index{\_sa\_feqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._sa_feqcons}\pysiglinewithargsret{\bfcode{\_sa\_feqcons}}{\emph{x}}{}
Calculate the \textbf{equations} constraints values for the first and intermediaries
sections of the plan when there are no conflicts.

The following expressions are evaluated:
\begin{gather}
\begin{split}\left\lbrace\begin{array}{lcl}
\varphi_1(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))
&-& q_{N_s-1,\ sec-1}\\
\varphi_2(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))
&-& u_{N_s-1,\ sec-1}\\
\end{array}\right.\end{split}\notag
\end{gather}\begin{description}
\item[{where:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\(sec\)
 & 
indicates the current plan section.
\\
\hline\end{tabulary}


\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the equations' values.

\end{description}

\end{fulllineitems}

\index{\_sa\_fieqcons() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._sa_fieqcons}\pysiglinewithargsret{\bfcode{\_sa\_fieqcons}}{\emph{x}}{}
Calculate the \textbf{inequations} constraints values for the first and intermediaries
sections of the plan when there are no conflicts.

The following expressions are evaluated:
\begin{gather}
\begin{split}\left\lbrace\begin{array}{lcl}
u_{max} - |\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\
u_{max} - |\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\
\dotsc\\
u_{max} - |\varphi_2(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec}))|\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-1,\ sec}),
\dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_0)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-1,\ sec}),
\dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_1)\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{1,\ sec}),
\dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{2,\ sec}),
\dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\
\dotsc\\
\mathrm{pt2obstacle}(\varphi_1(z(t_{N_s-1,\ sec}),
\dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_{M-1})\\
\end{array}\right.\end{split}\notag
\end{gather}\begin{description}
\item[{where:}] \leavevmode
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\(sec\)
 & 
indicates the current plan section.
\\
\hline
\(O_i\)
 & 
is the ith detected obstacle.
\\
\hline
\(M\)
 & 
is the number of detected obstacles.
\\
\hline
\(N_s\)
 & 
is the number of time samples for a plan section.
\\
\hline\end{tabulary}


\item[{Input}] \leavevmode
\emph{x}: optimization argument.

\item[{Return}] \leavevmode
Array with the inequations' values.

\end{description}

\end{fulllineitems}

\index{\_solve\_opt\_pbl() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot._solve_opt_pbl}\pysiglinewithargsret{\bfcode{\_solve\_opt\_pbl}}{}{}
Call the optimization solver with the appropriate parameters and parse
the information returned by it. This method updates the \code{\_C}, \code{\_dt\_final}
and \code{\_t\_final} attributes.

\end{fulllineitems}

\index{set\_option() (planning\_sim.Robot method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.set_option}\pysiglinewithargsret{\bfcode{set\_option}}{\emph{name}, \emph{value=None}}{}
Setter for some optimation parameters.

\end{fulllineitems}

\index{ctime (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.ctime}\pysigline{\bfcode{ctime}\strong{ = None}}
List of computation time spend for calculating each planned section.

\end{fulllineitems}

\index{eyed (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.eyed}\pysigline{\bfcode{eyed}\strong{ = None}}
Robot ID.

\end{fulllineitems}

\index{k\_mod (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.k_mod}\pysigline{\bfcode{k\_mod}\strong{ = None}}
Robot kinematic model.

\end{fulllineitems}

\index{planning\_process (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.planning_process}\pysigline{\bfcode{planning\_process}\strong{ = None}}
Planning process handler for where the planning routine is called.

\end{fulllineitems}

\index{rho (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.rho}\pysigline{\bfcode{rho}\strong{ = None}}
Robot's radius.

\end{fulllineitems}

\index{rtime (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.rtime}\pysigline{\bfcode{rtime}\strong{ = None}}
``Race'' time. Discrete time vector of the planning process.

\end{fulllineitems}

\index{sol (planning\_sim.Robot attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.Robot.sol}\pysigline{\bfcode{sol}\strong{ = None}}
Solution, i.e., finded path.

\end{fulllineitems}


\end{fulllineitems}



\section{WorldSim}
\label{Multi-robot motion planner:worldsim}

\bigskip\hrule{}\bigskip

\index{WorldSim (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.WorldSim}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{WorldSim}}{\emph{name\_id}, \emph{robots}, \emph{obstacles}, \emph{phy\_boundary}}{}
Bases: \href{http://docs.python.org/library/functions.html\#object}{\code{object}}

This class is a container of all simulation elements and also the
interface for running the simulation.
\index{run() (planning\_sim.WorldSim method)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.WorldSim.run}\pysiglinewithargsret{\bfcode{run}}{}{}
Run simulation by first calling the \href{http://docs.python.org/library/multiprocessing.html\#multiprocessing.Process.start}{\code{multiprocessing.Process.start()}} method to
initiate the motion planning of each robot. And secondly by parsing theirs solutions and
prompting the option to plot/save it.

\end{fulllineitems}


\end{fulllineitems}



\section{Communication message}
\label{Multi-robot motion planner:communication-message}

\bigskip\hrule{}\bigskip

\index{RobotMsg (class in planning\_sim)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RobotMsg}\pysiglinewithargsret{\strong{class }\code{planning\_sim.}\bfcode{RobotMsg}}{\emph{dp}, \emph{ip\_z1}, \emph{ip\_z2}, \emph{lz}}{}
Bases: \href{http://docs.python.org/library/functions.html\#object}{\code{object}}

Robot message class for exchanging information about theirs intentios.
\index{done\_planning (planning\_sim.RobotMsg attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RobotMsg.done_planning}\pysigline{\bfcode{done\_planning}\strong{ = None}}
Flag to indicate that the robot has finished its planning process.

\end{fulllineitems}

\index{intended\_path\_z1 (planning\_sim.RobotMsg attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RobotMsg.intended_path_z1}\pysigline{\bfcode{intended\_path\_z1}\strong{ = None}}
Intended path (z1 coordiante).

\end{fulllineitems}

\index{intended\_path\_z2 (planning\_sim.RobotMsg attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RobotMsg.intended_path_z2}\pysigline{\bfcode{intended\_path\_z2}\strong{ = None}}
Intended path (z2 coordiante).

\end{fulllineitems}

\index{latest\_z (planning\_sim.RobotMsg attribute)}

\begin{fulllineitems}
\phantomsection\label{Multi-robot motion planner:planning_sim.RobotMsg.latest_z}\pysigline{\bfcode{latest\_z}\strong{ = None}}
z value calculated on the previews planned section.

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{planning\_sim}}, \pageref{Multi-robot motion planner:module-planning_sim}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}

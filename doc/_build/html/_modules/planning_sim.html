<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>planning_sim &mdash; Motion Planning 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon_mp.ico"/>
    <link rel="top" title="Motion Planning 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Motion Planning 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for planning_sim</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;The planning_sim module implements classes to simulate a navigation</span>
<span class="sd">scenario consisting of one or more mobile robots that autonomously plan their</span>
<span class="sd">motion from an initial state to a final state avoiding static obstacles and</span>
<span class="sd">other robots, and respecting kinematic (including nonhonolonomic) constraints.</span>

<span class="sd">The motion planner is based on the experimental work developed by Michael Defoort</span>
<span class="sd">that seeks a near-optimal solution minimizing the time spend by a robot to</span>
<span class="sd">complete its mission.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="kn">as</span> <span class="nn">LA</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="kn">as</span> <span class="nn">si</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mpc</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin_slsqp</span>

<span class="c">###############################################################################</span>
<span class="c"># Obstacle</span>
<span class="c">###############################################################################</span>
<div class="viewcode-block" id="Obstacle"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Obstacle">[docs]</a><span class="k">class</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base class for implementing simulated obstacles.</span>

<span class="sd">    Input</span>
<span class="sd">        *position*: array-like type representing the obstacle&#39;s position (x,y).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Class constructor.</span>

<span class="sd">        Input</span>
<span class="sd">            *position*: array-like type representing the obstacle&#39;s position (x,y).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span> <span class="o">=</span> <span class="n">position</span>
        <span class="sd">&quot;&quot;&quot; Obstacle&#39;s centroid. Considered here the obstacle given position.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Obstacle.pt_2_obst"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Obstacle.pt_2_obst">[docs]</a>    <span class="k">def</span> <span class="nf">pt_2_obst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the point-to-obstacle distance less the offset value (as a float).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">))</span><span class="o">-</span><span class="n">offset</span>
</div>
<div class="viewcode-block" id="Obstacle.detected_dist"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Obstacle.detected_dist">[docs]</a>    <span class="k">def</span> <span class="nf">detected_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the detected distance of this obstacle as seen by a robot at the position pt</span>
<span class="sd">        (as a float).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">))</span>

<span class="c">###############################################################################</span>
<span class="c"># RoundObstacle</span>
<span class="c">###############################################################################</span></div></div>
<div class="viewcode-block" id="RoundObstacle"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.RoundObstacle">[docs]</a><span class="k">class</span> <span class="nc">RoundObstacle</span><span class="p">(</span><span class="n">Obstacle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Representation of an obstacle as a circle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>

        <span class="c"># call ancestor&#39;s __init__</span>
        <span class="n">Obstacle</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; x-coordinate of the obstacle centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; y-coordinate of the obstacle centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="sd">&quot;&quot;&quot; Obstacle radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RoundObstacle._plt_circle"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.RoundObstacle._plt_circle">[docs]</a>    <span class="k">def</span> <span class="nf">_plt_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;solid&#39;</span><span class="p">,</span> <span class="n">filled</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a :py:class:`matplotlib.patches.Circle` object representing the obstacle</span>
<span class="sd">        geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="c"># position</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="c"># radius</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="n">linestyle</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="n">filled</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RoundObstacle.plot"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.RoundObstacle.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Given a figure this method gets its active axes and plots a grey circle representing</span>
<span class="sd">        the obstacle as well as a second, concentric, dashed circle having the original circle</span>
<span class="sd">        radius plus the offset value as its own radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plt_circle</span><span class="p">(</span><span class="n">filled</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plt_circle</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s">&#39;k.&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RoundObstacle.pt_2_obst"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.RoundObstacle.pt_2_obst">[docs]</a>    <span class="k">def</span> <span class="nf">pt_2_obst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the point-to-obstacle distance less the offset value</span>
<span class="sd">        and less the obstacle radius (as a float).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Obstacle</span><span class="o">.</span><span class="n">pt_2_obst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>

<span class="c">###############################################################################</span>
<span class="c"># PolygonObstacle</span>
<span class="c">###############################################################################</span></div></div>
<div class="viewcode-block" id="PolygonObstacle"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.PolygonObstacle">[docs]</a><span class="k">class</span> <span class="nc">PolygonObstacle</span><span class="p">(</span><span class="n">Obstacle</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PolygonObstacle._calculate_polygon_area"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.PolygonObstacle._calculate_polygon_area">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_polygon_area</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the signed area of non-self-intersecting polygon</span>

<span class="sd">        Input</span>
<span class="sd">            *polygon*: Numeric array of points (longitude, latitude). It is assumed</span>
<span class="sd">                     to be closed, i.e. first and last points are identical</span>

<span class="sd">            *signed*: Optional flag deciding whether returned area retains its sign:</span>
<span class="sd">                    If points are ordered counter clockwise, the signed area</span>
<span class="sd">                    will be positive.</span>

<span class="sd">                    If points are ordered clockwise, it will be negative.</span>

<span class="sd">                    Default is False which means that the area is always positive.</span>
<span class="sd">        Output</span>
<span class="sd">            Area of polygon (subject to the value of argument signed)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Make sure it is numeric</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="c"># Check input</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Polygon is assumed to consist of coordinate pairs. &#39;</span>
               <span class="s">&#39;I got second dimension </span><span class="si">%i</span><span class="s"> instead of 2&#39;</span> <span class="o">%</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">msg</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Polygon is assumed to be closed. &#39;</span>
               <span class="s">&#39;However first and last coordinates are different: &#39;</span>
               <span class="s">&#39;(</span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">) and (</span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">msg</span>

        <span class="c"># Extract x and y coordinates</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c"># Area calculation</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>

        <span class="c"># Return signed or unsigned area</span>
        <span class="k">if</span> <span class="n">signed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PolygonObstacle._calculate_polygon_centroid"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.PolygonObstacle._calculate_polygon_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_polygon_centroid</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the centroid of non-self-intersecting polygon</span>

<span class="sd">        Input</span>
<span class="sd">            *polygon*: Numeric array of points (longitude, latitude). It is assumed</span>
<span class="sd">            to be closed, i.e. first and last points are identical</span>
<span class="sd">        Output</span>
<span class="sd">            Numeric (1 x 2) array of points representing the centroid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Make sure it is numeric</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="c"># Get area - needed to compute centroid</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">PolygonObstacle</span><span class="o">.</span><span class="n">_calculate_polygon_area</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Extract x and y coordinates</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cx</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">Cy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cy</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span>

        <span class="c"># Create Nx2 array and return</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">C</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="sd">&quot;&quot;&quot; Original polygon vertices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span> <span class="o">=</span> <span class="n">PolygonObstacle</span><span class="o">.</span><span class="n">_calculate_polygon_centroid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="sd">&quot;&quot;&quot; Obstacle&#39;s centroid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_circle_radius</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="o">-</span><span class="n">vertices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="sd">&quot;&quot;&quot; Compute the radius of a bounding circle for the obstacle centred on the centroid.</span>

<span class="sd">        .. warning:: This is not necessarily the smaller bounding circle. It would be better to</span>
<span class="sd">                 get the the midpoint of the greatest line segment formed by two of the</span>
<span class="sd">                 polygons vertices as the circle center and half of the that line segment</span>
<span class="sd">                 as its radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># call ancestor&#39;s __init__</span>
        <span class="n">Obstacle</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; x-coordinate of the obstacle centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; y-coordinate of the obstacle centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_aug_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="sd">&quot;&quot;&quot; Represent the auxiliar vertices of the</span>
<span class="sd">        convex set resulting from the Minkowski difference between obstacle</span>
<span class="sd">        and robot geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># create linear equations used when computing distance from obstacle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lines_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">va</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span> <span class="c"># v: current vertex, vb: previous vertex, va: following vertex</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)):</span>

            <span class="c"># calculate normal vector to the edge difined by v and vb</span>
            <span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c"># calculate normal vector to the edge difined by v and va</span>
            <span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">va</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c"># create 3 line equations:</span>
            <span class="c"># * first is the orthogonal line to the v-vb edge passing thru v</span>
            <span class="c"># * second is the orthogonal line to the v-va edge passing thru v</span>
            <span class="c"># * third is the line coincident to the v-va edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lines_list</span> <span class="o">+=</span> <span class="p">[[(</span><span class="n">vec_b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">vec_b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">vec_a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">vec_a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vec_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">va</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">va</span><span class="p">[</span><span class="mi">1</span><span class="p">])]]</span>

<div class="viewcode-block" id="PolygonObstacle._create_aug_vertices"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.PolygonObstacle._create_aug_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">_create_aug_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create augmented vertices from original vertices and offset value</span>

<span class="sd">        Input</span>
<span class="sd">            *offset*: Real value used as offset from original vertices. Can also</span>
<span class="sd">            be seen as the radius of the circle that will be subtracted (in the</span>
<span class="sd">            Minkowski difference sense) from the obstacle geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_vertices_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">va</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">unit_vec_b</span> <span class="o">=</span> <span class="n">vec_b</span><span class="o">/</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_b</span><span class="p">)</span>
            <span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">va</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">unit_vec_a</span> <span class="o">=</span> <span class="n">vec_a</span><span class="o">/</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span>

            <span class="n">new_vertices_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">offset</span><span class="o">*</span><span class="n">unit_vec_b</span><span class="o">+</span><span class="n">v</span><span class="p">,</span> <span class="n">offset</span><span class="o">*</span><span class="n">unit_vec_a</span><span class="o">+</span><span class="n">v</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aug_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_vertices_list</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PolygonObstacle.plot"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.PolygonObstacle.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Given a figure this method gets its active axes and plots a grey polygon representing</span>
<span class="sd">        the obstacle as well as some dashed lines associated with the Minkowski difference of</span>
<span class="sd">        the obstacle representation and a circle of radius equals to offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_aug_vertices</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">offset</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span>
                <span class="n">ls</span><span class="o">=</span><span class="s">&#39;dashed&#39;</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&#39;solid&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aug_vertices</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s">&#39;k.&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PolygonObstacle.pt_2_obst"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.PolygonObstacle.pt_2_obst">[docs]</a>    <span class="k">def</span> <span class="nf">pt_2_obst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate distance from point to the obstacle</span>

<span class="sd">        Input</span>
<span class="sd">            *pt*: cardinal coordinates of the point</span>

<span class="sd">            *offset*: offset distance that will be subtracted from the actual</span>
<span class="sd">            point-to-obstacle distance</span>

<span class="sd">        Output</span>
<span class="sd">            Real number representing the distance pt_2_obstacle less offset. Negative value means</span>
<span class="sd">            that the point is closer then the offset value from the obstacle, or even inside it.</span>

<span class="sd">        .. todo:: Fix error handling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># update augmented vertices using offset value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_aug_vertices</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="c"># compute the signed distances from the point (pt) to each of the...</span>
        <span class="c"># ... 3*card(_orig_vertices) lines</span>
        <span class="n">signed_dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lines_list</span><span class="p">:</span>
            <span class="n">s_dist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>

                <span class="c"># distance pt-2-line calculate replacing pt in line equation...</span>
                <span class="c"># ... divided by sqrt(a^2+b^2)</span>
                <span class="n">s_dist</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))]</span>

            <span class="n">signed_dists</span> <span class="o">+=</span> <span class="p">[</span><span class="n">s_dist</span><span class="p">]</span>

        <span class="c"># calculate the zone where the point (pt) is</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="c"># if the point is &quot;between&quot; the 2 orthogonal lines that passes thru the vertex</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mf">0.0</span> <span class="ow">and</span> \
                    <span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span> \
                    <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>

                <span class="c"># return point to point dist less offset</span>
                <span class="k">return</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pt</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">])</span><span class="o">-</span><span class="n">offset</span>

            <span class="c"># if the point is &quot;between&quot; the edge v-va, and the 2 lines...</span>
            <span class="c"># ...passing thru v and va that are _|_ to the edge</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="ow">and</span> \
                    <span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="mf">0.0</span> <span class="ow">and</span> \
                    <span class="n">signed_dists</span><span class="p">[(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span> \
                    <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>

                <span class="c"># return the distance pt_2_line less offset</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">-</span><span class="n">offset</span>

        <span class="c"># if it reachs this line it probably means that the point (pt) is inside the obstacle</span>
        <span class="n">pt_is_inside</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># verifying if the point is realy inside the obstacle</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pt_is_inside</span> <span class="o">=</span> <span class="n">pt_is_inside</span> <span class="ow">and</span> <span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;=</span><span class="mf">0.0</span>

        <span class="c"># if pt_is_inside is still true</span>
        <span class="k">if</span> <span class="n">pt_is_inside</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># compute negative distance from the closest edge less offset</span>
            <span class="n">pt_2_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">signed_dists</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">return</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">pt_2_edges</span><span class="p">)</span><span class="o">-</span><span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;I</span><span class="se">\&#39;</span><span class="s">m out of ideas about what happend. WhereTF is the path going?&#39;</span>
            <span class="c"># stop execution TODO error handling etc</span>

<span class="c">###############################################################################</span>
<span class="c"># Boundary</span>
<span class="c">###############################################################################</span></div></div>
<div class="viewcode-block" id="Boundary"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Boundary">[docs]</a><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; Min bound in the x direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; Max bound in the x direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; Min bound in the y direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot; Max bound on y direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="c">###############################################################################</span>
<span class="c"># Unicycle Kinematic Model</span>
<span class="c">###############################################################################</span></div>
<div class="viewcode-block" id="UnicycleKineModel"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.UnicycleKineModel">[docs]</a><span class="k">class</span> <span class="nc">UnicycleKineModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This class defines the kinematic model of an unicycle mobile robot.</span>

<span class="sd">    Unicycle kinematic model:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\begin{array}{c}</span>
<span class="sd">        \dot{q} = \mathrm{f}(q, u) \Rightarrow\\\\</span>
<span class="sd">        \left[\\begin{array}{c}</span>
<span class="sd">        \dot{x}\\\\</span>
<span class="sd">        \dot{y}\\\\</span>
<span class="sd">        \dot{\\theta}</span>
<span class="sd">        \end{array}\\right]=</span>
<span class="sd">        \left[\\begin{array}{c}</span>
<span class="sd">        v\cos(\\theta)\\\\</span>
<span class="sd">        v\sin(\\theta)\\\\</span>
<span class="sd">        w</span>
<span class="sd">        \end{array}\\right]</span>
<span class="sd">        \end{array}</span>

<span class="sd">    Changing variables (:math:`z = [x, y]^T`) we can rewrite the system using the</span>
<span class="sd">    flat output :math:`z` as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \left[\\begin{array}{c}</span>
<span class="sd">        x\\\\</span>
<span class="sd">        y\\\\</span>
<span class="sd">        \\theta\\\\</span>
<span class="sd">        v\\\\</span>
<span class="sd">        w</span>
<span class="sd">        \end{array}\\right]=</span>
<span class="sd">        \left[\\begin{array}{c}</span>
<span class="sd">        z_1\\\\</span>
<span class="sd">        z_2\\\\</span>
<span class="sd">        \\arctan(\dot{z}_2/\dot{z}_1)\\\\</span>
<span class="sd">        \\sqrt{\dot{z}_{1}^{2} + \dot{z}_{2}^{2}}\\\\</span>
<span class="sd">        \\dfrac{\dot{z}_{1}\ddot{z}_{2} - \dot{z}_{2}\ddot{z}_{1}}{\dot{z}_{1}^{2}+\dot{z}_{2}^{2}}</span>
<span class="sd">        \end{array}\\right]</span>

<span class="sd">    where the the state and input vector (:math:`q, v`) are function of :math:`z`</span>
<span class="sd">    and its derivatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="UnicycleKineModel._unsigned_angle"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.UnicycleKineModel._unsigned_angle">[docs]</a>    <span class="k">def</span> <span class="nf">_unsigned_angle</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Map signed angles (:math:`\\theta \in (-\pi, \pi]`) to unsigned</span>
<span class="sd">        (:math:`\\theta \in [0, 2\pi)`).</span>

<span class="sd">        .. note:: Method not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">angle</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="n">angle</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">q_init</span><span class="p">,</span>
            <span class="n">q_final</span><span class="p">,</span>
            <span class="n">u_init</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="n">u_final</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="n">u_max</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span>
            <span class="n">a_max</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]):</span>
        <span class="c"># Control</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_dim</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="sd">&quot;&quot;&quot; Input vector order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="sd">&quot;&quot;&quot; Initial input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">u_final</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="sd">&quot;&quot;&quot; Final input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">u_max</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="sd">&quot;&quot;&quot; Absolute max input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">a_max</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="sd">&quot;&quot;&quot; Absolute maximum values for the first derivative of the input vector.</span>

<span class="sd">        .. note:: Value not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># State</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_dim</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="sd">&quot;&quot;&quot; State vector order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">q_init</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c">#angle in [-pi, pi]</span>
        <span class="sd">&quot;&quot;&quot; Initial state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">q_final</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c">#angle in [-pi, pi]</span>
        <span class="sd">&quot;&quot;&quot; Final state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Flat output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_dim</span>
        <span class="sd">&quot;&quot;&quot; Flat output vector order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_init</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Initial flat output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_final</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; Final flat output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="sd">&quot;&quot;&quot; Number of flat output derivatives that are needed to calculate the state</span>
<span class="sd">        and input vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="UnicycleKineModel.phi_0"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.UnicycleKineModel.phi_0">[docs]</a>    <span class="k">def</span> <span class="nf">phi_0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns :math:`z` given :math:`q`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="UnicycleKineModel.phi_1"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.UnicycleKineModel.phi_1">[docs]</a>    <span class="k">def</span> <span class="nf">phi_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns :math:`[x\\ y\\ \\theta]^T` given :math:`[z\\ \dot{z}\\ \dotsc\\ z^{(l)}]`</span>
<span class="sd">        (only :math:`z` and :math:`\dot{z}` are used). :math:`\\theta` is in the range</span>
<span class="sd">        :math:`(-\pi, \pi]`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\begin{array}{l}</span>
<span class="sd">            \\varphi_1(z(t_k),\dotsc,z^{(l)}(t_k))=\\</span>
<span class="sd">            \left[\\begin{array}{c}</span>
<span class="sd">            x\\\\</span>
<span class="sd">            y\\\\</span>
<span class="sd">            \omega</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            \left[\\begin{array}{c}</span>
<span class="sd">            z_1\\\\</span>
<span class="sd">            z_2\\\\</span>
<span class="sd">            \\arctan(\dot{z}_2/\dot{z}_1)\\\\</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            \end{array}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">zl</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Bad zl input. Returning zeros&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s">&#39;0.0; 0.0; 0.0&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="UnicycleKineModel.phi_2"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.UnicycleKineModel.phi_2">[docs]</a>    <span class="k">def</span> <span class="nf">phi_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns :math:`[v\\ \omega]^T` given :math:`[z\\ \dot{z}\\ \dotsc\\ z^{(l)}]`</span>
<span class="sd">        (only :math:`\dot{z}` and :math:`\ddot{z}` are used).</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\begin{array}{l}</span>
<span class="sd">            \\varphi_2(z(t_k),\dotsc,z^{(l)}(t_k))=\\</span>
<span class="sd">            \left[\\begin{array}{c}</span>
<span class="sd">            v\\\\</span>
<span class="sd">            \omega</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            = \left[\\begin{array}{c}</span>
<span class="sd">            \\sqrt{\dot{z}_{1}^{2} + \dot{z}_{2}^{2}}\\\\</span>
<span class="sd">            \\dfrac{\dot{z}_{1}\ddot{z}_{2} -</span>
<span class="sd">            \dot{z}_{2}\ddot{z}_{1}}{\dot{z}_{1}^{2}+\dot{z}_{2}^{2}}</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            \end{array}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">zl</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="c"># Prevent division by zero</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">zl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])],</span> \
                    <span class="p">[(</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> \
                    <span class="p">)</span><span class="o">/</span><span class="n">den</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Bad zl input. Returning zeros&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s">&#39;0.0; 0.0&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="UnicycleKineModel.phi_3"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.UnicycleKineModel.phi_3">[docs]</a>    <span class="k">def</span> <span class="nf">phi_3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns :math:`[\dot{v}\\ \dot{\omega}]^T` given</span>
<span class="sd">        :math:`[z\\ \dot{z}\\ \dotsc\\ z^{(l+1)}]`.</span>
<span class="sd">        (only :math:`\dot{z}`, :math:`\ddot{z}` and :math:`z^{(3)}` are used).</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\begin{array}{l}</span>
<span class="sd">            \\varphi_3(z(t_k),\dotsc,z^{(l+1)}(t_k))=\\</span>
<span class="sd">            \left[\\begin{array}{c}</span>
<span class="sd">            \dot{v}\\\\</span>
<span class="sd">            \dot{\omega}</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            = \left[\\begin{array}{c}</span>
<span class="sd">            \\frac{\partial}{\partial t}v\\\\</span>
<span class="sd">            \\frac{\partial}{\partial t}\omega</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            = \left[\\begin{array}{c}</span>
<span class="sd">            \\frac{\dot{z}_1\ddot{z}_1 + \dot{z}_2\ddot{z}_2}{\|\dot{z}\|}\\\\</span>
<span class="sd">            \\frac{(\ddot{z}_1\ddot{z}_2+ z^{(3)}_2\dot{z}_1 -</span>
<span class="sd">            (\ddot{z}_2\ddot{z}_1+z^{(3)}_1\dot{z}_2))\|\dot{z}\|^2-</span>
<span class="sd">            2(\dot{z}_1\ddot{z}_2-\dot{z}_2\ddot{z}_1)\|\dot{z}\|\dot{v}}{\|\dot{z}\|^4}</span>
<span class="sd">            \end{array}\\right]</span>
<span class="sd">            \end{array}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">zl</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="c"># Prevent division by zero</span>
            <span class="n">dz_norm</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">zl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">dz_norm</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="p">(</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">den</span>
            <span class="n">dw</span> <span class="o">=</span> <span class="p">((</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span> \
                    <span class="p">(</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="p">(</span><span class="n">dz_norm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> \
                    <span class="p">(</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">zl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">dz_norm</span><span class="o">*</span><span class="n">dv</span><span class="p">)</span><span class="o">/</span><span class="n">den</span><span class="o">**</span><span class="mi">4</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="n">dv</span><span class="p">],</span> <span class="p">[</span><span class="n">dw</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Bad zl input. Returning zeros&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s">&#39;0.0; 0.0&#39;</span><span class="p">)</span>

<span class="c">###############################################################################</span>
<span class="c"># Communication Msg</span>
<span class="c">###############################################################################</span></div></div>
<div class="viewcode-block" id="RobotMsg"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.RobotMsg">[docs]</a><span class="k">class</span> <span class="nc">RobotMsg</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Robot message class for exchanging information about theirs intentios.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">ip_z1</span><span class="p">,</span> <span class="n">ip_z2</span><span class="p">,</span> <span class="n">lz</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done_planning</span> <span class="o">=</span> <span class="n">dp</span>
        <span class="sd">&quot;&quot;&quot; Flag to indicate that the robot has finished its planning process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intended_path_z1</span> <span class="o">=</span> <span class="n">ip_z1</span>
        <span class="sd">&quot;&quot;&quot; Intended path (z1 coordiante).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intended_path_z2</span> <span class="o">=</span> <span class="n">ip_z2</span>
        <span class="sd">&quot;&quot;&quot; Intended path (z2 coordiante).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_z</span> <span class="o">=</span> <span class="n">lz</span>
        <span class="sd">&quot;&quot;&quot; z value calculated on the previews planned section.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="c">###############################################################################</span>
<span class="c"># Robot</span>
<span class="c">###############################################################################</span></div>
<div class="viewcode-block" id="Robot"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot">[docs]</a><span class="k">class</span> <span class="nc">Robot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class for creating a robot in the simulation.</span>
<span class="sd">    It implements the Defoort&#39;s experimental motion planning algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">eyed</span><span class="p">,</span>
            <span class="n">kine_model</span><span class="p">,</span>
            <span class="n">obstacles</span><span class="p">,</span>
            <span class="n">phy_boundary</span><span class="p">,</span>
            <span class="n">neigh</span><span class="p">,</span>                  <span class="c"># neighbors to whom this robot shall talk...</span>
                                    <span class="c"># ...(used for conflict only, not communic)</span>
            <span class="n">N_s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">n_knots</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
            <span class="n">t_init</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">t_sup</span><span class="o">=</span><span class="mf">1e10</span><span class="p">,</span>
            <span class="n">Tc</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">Tp</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
            <span class="n">Td</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
            <span class="n">rho</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
            <span class="n">detec_rho</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
            <span class="n">com_range</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span>
            <span class="n">def_epsilon</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">safe_epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">ls_time_opt_scale</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
            <span class="n">dist_opt_offset</span> <span class="o">=</span> <span class="mf">1e2</span><span class="p">,</span>
            <span class="n">ls_min_dist</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eyed</span> <span class="o">=</span> <span class="n">eyed</span>
        <span class="sd">&quot;&quot;&quot; Robot ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span> <span class="o">=</span> <span class="n">kine_model</span>
        <span class="sd">&quot;&quot;&quot; Robot kinematic model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obst</span> <span class="o">=</span> <span class="n">obstacles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_bound</span> <span class="o">=</span> <span class="n">phy_boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot; Solution, i.e., finded path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtime</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot; &quot;Race&quot; time. Discrete time vector of the planning process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctime</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot; List of computation time spend for calculating each planned section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_neigh</span> <span class="o">=</span> <span class="n">neigh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span> <span class="o">=</span> <span class="n">N_s</span> <span class="c"># no of samples for discretization of time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span> <span class="o">=</span> <span class="n">n_knots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_init</span> <span class="o">=</span> <span class="n">t_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_sup</span> <span class="o">=</span> <span class="n">t_sup</span> <span class="c"># superior limit of time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span> <span class="o">=</span> <span class="n">Tc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tp</span> <span class="o">=</span> <span class="n">Tp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Td</span> <span class="o">=</span> <span class="n">Td</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="sd">&quot;&quot;&quot; Robot&#39;s radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d_rho</span> <span class="o">=</span> <span class="n">detec_rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_com_range</span> <span class="o">=</span> <span class="n">com_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_epsilon</span> <span class="o">=</span> <span class="n">def_epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_safe_epsilon</span> <span class="o">=</span> <span class="n">safe_epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_lock</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ls_time_opt_scale</span> <span class="o">=</span> <span class="n">ls_time_opt_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist_opt_offset</span> <span class="o">=</span> <span class="n">dist_opt_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ls_min_dist</span> <span class="o">=</span> <span class="n">ls_min_dist</span>

        <span class="c"># number of robots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_robots</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># index for sliding windows</span>
        <span class="n">td_step</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Td</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_t_init</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tp_step</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tp</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_t_init</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tcd_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="o">/</span><span class="n">td_step</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tcp_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="o">/</span><span class="n">tp_step</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tcd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tcd_idx</span><span class="o">*</span><span class="n">td_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tcp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tcp_idx</span><span class="o">*</span><span class="n">tp_step</span>

        <span class="c"># optimization parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxit</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fs_maxit</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ls_maxit</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_acc</span> <span class="o">=</span> <span class="mf">1e-6</span>

        <span class="c"># init planning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detected_obst_idxs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_latest_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latest_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">z_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_final_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">z_final</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span> <span class="c"># B-spline order (integer | d &gt; l+1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">-</span> <span class="mi">1</span> <span class="c"># nb of ctrl points</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_dz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_comp_times</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Instantiating the planning process</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">planning_process</span> <span class="o">=</span> <span class="n">mpc</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">Robot</span><span class="o">.</span><span class="n">_plan</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">))</span>
        <span class="sd">&quot;&quot;&quot; Planning process handler for where the planning routine is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Robot.set_option"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot.set_option">[docs]</a>    <span class="k">def</span> <span class="nf">set_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Setter for some optimation parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;maxit&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxit</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;fs_maxit&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fs_maxit</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;ls_maxit&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ls_maxit</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;acc&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_acc</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;com_link&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;sol&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sol</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;rtime&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rtime</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;ctime&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;tc_syncer&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;tc_syncer_cond&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;conflict_syncer&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer</span> <span class="o">=</span> <span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_robots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;conflict_syncer_conds&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;log_lock&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log_lock</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="s">&#39;Unknown parameter &#39;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;, nothing will be set&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._gen_knots"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._gen_knots">[docs]</a>    <span class="k">def</span> <span class="nf">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_init</span><span class="p">,</span> <span class="n">t_final</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate b-spline knots given initial and final times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gk</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">t_init</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">t_final</span><span class="o">-</span><span class="n">t_init</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_init</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)]</span>
        <span class="n">knots</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">gk</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
        <span class="n">knots</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">t_final</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._comb_bsp"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._comb_bsp">[docs]</a>    <span class="k">def</span> <span class="nf">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ctrl_pts</span><span class="p">,</span> <span class="n">deriv_order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Combine base b-splines into a Bezier curve given control points and derivate order.</span>

<span class="sd">        Input</span>
<span class="sd">            *ctrl_pts*: numpy array with dimension :math:`n_{ctrl}\\times z_{dim}`, :math:`n_{ctrl}`</span>
<span class="sd">            being the number of</span>
<span class="sd">            control points and :math:`z_{dim}` the flat output dimension.</span>

<span class="sd">            *deriv_order*: derivative order of the Bezier curve.</span>

<span class="sd">            *t*: discrete time array.</span>

<span class="sd">        Return</span>
<span class="sd">            :math:`z_{dim}\\times N_s` numpy array representing the resulting Bezier curve,</span>
<span class="sd">            :math:`z_{dim}` being</span>
<span class="sd">            the flat output dimension and :math:`N_{s}` the discrete time array dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span><span class="p">,</span> <span class="c"># knots</span>
                <span class="n">ctrl_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="c"># first dim ctrl pts</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c"># b-spline degree</span>

        <span class="c"># interpolation</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tup</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="n">deriv_order</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span><span class="p">,</span>
                    <span class="n">ctrl_pts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">z</span><span class="p">,</span>
                    <span class="n">si</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tup</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="n">deriv_order</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span>
</div>
<div class="viewcode-block" id="Robot._log"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._log">[docs]</a>    <span class="k">def</span> <span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logid</span><span class="p">,</span> <span class="n">strg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Log writer (multiprocess safe).</span>

<span class="sd">        Input</span>
<span class="sd">            *logid*:</span>
<span class="sd">                === ===============</span>
<span class="sd">                &#39;d&#39; for debug</span>
<span class="sd">                &#39;i&#39; for information</span>
<span class="sd">                &#39;w&#39; for warning</span>
<span class="sd">                &#39;e&#39; for error</span>
<span class="sd">                &#39;c&#39; for critical</span>
<span class="sd">                === ===============</span>

<span class="sd">            *strg*: log string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">logid</span> <span class="o">==</span> <span class="s">&#39;d&#39;</span><span class="p">:</span>
            <span class="n">log_call</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">debug</span>
        <span class="k">elif</span> <span class="n">logid</span> <span class="o">==</span> <span class="s">&#39;i&#39;</span><span class="p">:</span>
            <span class="n">log_call</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">info</span>
        <span class="k">elif</span> <span class="n">logid</span> <span class="o">==</span> <span class="s">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">log_call</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">warning</span>
        <span class="k">elif</span> <span class="n">logid</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">log_call</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">error</span>
        <span class="k">elif</span> <span class="n">logid</span> <span class="o">==</span> <span class="s">&#39;c&#39;</span><span class="p">:</span>
            <span class="n">log_call</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">critical</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_call</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">debug</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_lock</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="n">log_call</span><span class="p">(</span><span class="n">strg</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_lock</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Robot._detect_obst"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._detect_obst">[docs]</a>    <span class="k">def</span> <span class="nf">_detect_obst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determinate which obstacles are within the detection radius.</span>
<span class="sd">        This method updates the :attr:`_detected_obst_idxs`</span>
<span class="sd">        private attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">)):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">detected_dist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_rho</span><span class="p">:</span>
                <span class="n">idx_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detected_obst_idxs</span> <span class="o">=</span> <span class="n">idx_list</span>
</div>
<div class="viewcode-block" id="Robot._ls_sa_criterion"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._ls_sa_criterion">[docs]</a>    <span class="k">def</span> <span class="nf">_ls_sa_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cost function to be minimized used for optimizing</span>
<span class="sd">        the last section of the plan when no conflicts are detected.</span>
<span class="sd">        It calculates the square of the total plan time.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Cost value.</span>

<span class="sd">        .. warning:: Optimization solver can misbehave for costs too big (:math:`&gt; 10^{6}`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_time_opt_scale</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
</div>
<div class="viewcode-block" id="Robot._ls_sa_feqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._ls_sa_feqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_ls_sa_feqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **equations** constraints values for the last section of the plan when</span>
<span class="sd">        there are no conflicts.</span>

<span class="sd">        The following expressions are evaluated:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left\lbrace\\begin{array}{lcl}</span>
<span class="sd">            \\varphi_1(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))</span>
<span class="sd">            &amp;-&amp; q_{N_s-1,\ sec-1}\\\\</span>
<span class="sd">            \\varphi_1(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec}))</span>
<span class="sd">            &amp;-&amp; q_{final}\\\\</span>
<span class="sd">            \\varphi_2(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))</span>
<span class="sd">            &amp;-&amp;u_{N_s-1,\ sec-1}\\\\</span>
<span class="sd">            \\varphi_2(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec})) &amp;-&amp; u_{final}\\\\</span>
<span class="sd">            \end{array}\\right.</span>
<span class="sd">        where:</span>
<span class="sd">            =========== ===================================</span>
<span class="sd">            :math:`sec` indicates the current plan section.</span>
<span class="sd">            =========== ===================================</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the equations&#39; values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># get time and ctrl pts</span>
        <span class="n">dt_final</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dt_final</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="c"># get new knots and the flat output initial and final values for this plan section.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_final</span><span class="p">)</span>
        <span class="n">dztinit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dztinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dztinit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">dztfinal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="n">t_final</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dztfinal</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dztfinal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="n">t_final</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># calculate equations</span>
        <span class="n">eq_cons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">(</span><span class="n">dztinit</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_q</span><span class="p">)))</span><span class="o">+</span>\
                <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">(</span><span class="n">dztfinal</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_final</span><span class="p">)))</span><span class="o">+</span>\
                <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">(</span><span class="n">dztinit</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_u</span><span class="p">)))</span><span class="o">+</span>\
                <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">(</span><span class="n">dztfinal</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_final</span><span class="p">)))</span>

        <span class="c"># Count how many inequations are not respected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_eq_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">ec</span> <span class="k">for</span> <span class="n">ec</span> <span class="ow">in</span> <span class="n">eq_cons</span> <span class="k">if</span> <span class="n">ec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">eq_cons</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._ls_sa_fieqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._ls_sa_fieqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_ls_sa_fieqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **inequations** constraints values for the last section of the plan when</span>
<span class="sd">        there are no conflicts.</span>

<span class="sd">        The following expressions are evaluated:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left\lbrace\\begin{array}{lcl}</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{N_s-2,\ sec}),\dotsc,z^{(l)}(t_{N_s-2,\ sec}))|\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \end{array}\\right.</span>

<span class="sd">        where:</span>
<span class="sd">            =========== =================================================</span>
<span class="sd">            :math:`sec` indicates the current plan section.</span>
<span class="sd">            :math:`O_i` is the ith detected obstacle.</span>
<span class="sd">            :math:`M`   is the number of detected obstacles.</span>
<span class="sd">            :math:`N_s` is the number of time samples for a plan section.</span>
<span class="sd">            =========== =================================================</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the inequations&#39; values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt_final</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dt_final</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_final</span><span class="p">)</span>

        <span class="n">mtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_final</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">)</span>

        <span class="c"># get a list over time of the matrix [z dz ddz](t) t in [tk, tk+Tp]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="n">mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="n">mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dztTp</span> <span class="o">=</span> <span class="p">[</span><span class="n">dzt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">dzt</span> <span class="ow">in</span> <span class="n">dz</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c"># get a list over time of command values u(t)</span>
        <span class="n">utTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c"># get a list over time of values q(t)</span>
        <span class="n">qtTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c">## Obstacles constraints</span>
        <span class="c"># N_s*nb_obst_detected</span>
        <span class="n">obst_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detected_obst_idxs</span><span class="p">:</span>
            <span class="n">obst_cons</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">pt_2_obst</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>\
                    <span class="k">for</span> <span class="n">qt</span> <span class="ow">in</span> <span class="n">qtTp</span><span class="p">]</span>

        <span class="c">## Max speed constraints</span>
        <span class="c"># N_s*u_dim inequations</span>
        <span class="n">max_speed_cons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> \
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)]</span><span class="k">for</span> <span class="n">ut</span> <span class="ow">in</span> <span class="n">utTp</span><span class="p">]))</span>

        <span class="c"># Create final array</span>
        <span class="n">ieq_cons</span> <span class="o">=</span> <span class="n">obst_cons</span> <span class="o">+</span> <span class="n">max_speed_cons</span>

        <span class="c"># Count how many inequations are not respected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_ieq_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">ieq</span> <span class="k">for</span> <span class="n">ieq</span> <span class="ow">in</span> <span class="n">ieq_cons</span> <span class="k">if</span> <span class="n">ieq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ieq_cons</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._sa_criterion"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._sa_criterion">[docs]</a>    <span class="k">def</span> <span class="nf">_sa_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cost function to be minimized used for optimizing</span>
<span class="sd">        the first and intermediaries sections of the plan when no conflicts are detected.</span>

<span class="sd">        It calculates the distance between the final position of the proposed plan and</span>
<span class="sd">        the *goal point*.</span>

<span class="sd">        The *goal point* is calcualted as follows:</span>

<span class="sd">        .. todo:: Add the expression for computing the goal point.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Cost value.</span>

<span class="sd">        .. warning:: Optimization solver can misbehave for costs too big (:math:`&gt; 10^{6}`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">qTp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

        <span class="n">cte</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="c"># TODO no magic constants</span>
        <span class="n">pos2target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_final</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span>
        <span class="n">pos2target_norm</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pos2target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos2target_norm</span> <span class="o">&gt;</span> <span class="n">cte</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="p">:</span>
            <span class="n">goal_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="o">+</span><span class="n">pos2target</span><span class="o">/</span><span class="n">pos2target_norm</span><span class="o">*</span><span class="n">cte</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">elif</span> <span class="n">pos2target_norm</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="p">:</span>
            <span class="n">goal_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="o">+</span><span class="n">pos2target</span><span class="o">/</span><span class="n">pos2target_norm</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">goal_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_final</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">qTp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">goal_pt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c"># TODO</span>
        <span class="k">if</span> <span class="n">cost</span> <span class="o">&gt;</span> <span class="mf">1e6</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{}: Big problem {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">cost</span><span class="p">))</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;R{}: Big problem {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">cost</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cost</span>
</div>
<div class="viewcode-block" id="Robot._sa_feqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._sa_feqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_sa_feqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **equations** constraints values for the first and intermediaries</span>
<span class="sd">        sections of the plan when there are no conflicts.</span>

<span class="sd">        The following expressions are evaluated:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left\lbrace\\begin{array}{lcl}</span>
<span class="sd">            \\varphi_1(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))</span>
<span class="sd">            &amp;-&amp; q_{N_s-1,\ sec-1}\\\\</span>
<span class="sd">            \\varphi_2(z(t_{0,\ sec}),\dotsc,z^{(l)}(t_{0,\ sec}))</span>
<span class="sd">            &amp;-&amp; u_{N_s-1,\ sec-1}\\\\</span>
<span class="sd">            \end{array}\\right.</span>

<span class="sd">        where:</span>
<span class="sd">            =========== =================================================</span>
<span class="sd">            :math:`sec` indicates the current plan section.</span>
<span class="sd">            =========== =================================================</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the equations&#39; values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="n">dztinit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dztinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dztinit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># dimension: q_dim + u_dim</span>
        <span class="n">eq_cons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">(</span><span class="n">dztinit</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_q</span><span class="p">)))</span><span class="o">+</span>\
               <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">(</span><span class="n">dztinit</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_u</span><span class="p">)))</span>

        <span class="c"># Count how many equations are not respected</span>
        <span class="n">unsatisf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eq_cons</span> <span class="k">if</span> <span class="n">eq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_eq_values</span> <span class="o">=</span> <span class="n">unsatisf_list</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">eq_cons</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._sa_fieqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._sa_fieqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_sa_fieqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **inequations** constraints values for the first and intermediaries</span>
<span class="sd">        sections of the plan when there are no conflicts.</span>

<span class="sd">        The following expressions are evaluated:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left\lbrace\\begin{array}{lcl}</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec}))|\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \end{array}\\right.</span>

<span class="sd">        where:</span>
<span class="sd">            =========== =================================================</span>
<span class="sd">            :math:`sec` indicates the current plan section.</span>
<span class="sd">            :math:`O_i` is the ith detected obstacle.</span>
<span class="sd">            :math:`M`   is the number of detected obstacles.</span>
<span class="sd">            :math:`N_s` is the number of time samples for a plan section.</span>
<span class="sd">            =========== =================================================</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the inequations&#39; values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="c"># get a list over time of the matrix [z dz ddz](t) t in [t_{k+1}, t_k+Tp]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dztTp</span> <span class="o">=</span> <span class="p">[</span><span class="n">dzt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">dzt</span> <span class="ow">in</span> <span class="n">dz</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c"># get a list over time of command values u(t)</span>
        <span class="n">utTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c"># get a list over time of values q(t)</span>
        <span class="n">qtTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c">## Obstacles constraints</span>
        <span class="c"># N_s*nb_obst_detected</span>
        <span class="n">obst_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detected_obst_idxs</span><span class="p">:</span>
            <span class="n">obst_cons</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">pt_2_obst</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>\
                    <span class="k">for</span> <span class="n">qt</span> <span class="ow">in</span> <span class="n">qtTp</span><span class="p">]</span>

        <span class="c">## Max speed constraints</span>
        <span class="c"># N_s*u_dim inequations</span>
        <span class="n">max_speed_cons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)]</span>\
                <span class="k">for</span> <span class="n">ut</span> <span class="ow">in</span> <span class="n">utTp</span><span class="p">]))</span>

        <span class="c"># Create final array</span>
        <span class="n">ieq_cons</span> <span class="o">=</span> <span class="n">obst_cons</span> <span class="o">+</span> <span class="n">max_speed_cons</span>

        <span class="c"># Count how many inequations are not respected</span>
        <span class="n">unsatisf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ieq</span> <span class="k">for</span> <span class="n">ieq</span> <span class="ow">in</span> <span class="n">ieq_cons</span> <span class="k">if</span> <span class="n">ieq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_ieq_values</span> <span class="o">=</span> <span class="n">unsatisf_list</span>

        <span class="c"># return arrray where each element is an inequation constraint</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ieq_cons</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._ls_co_criterion"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._ls_co_criterion">[docs]</a>    <span class="k">def</span> <span class="nf">_ls_co_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cost function to be minimized used for optimizing</span>
<span class="sd">        the last section of the plan when conflicts are detected.</span>
<span class="sd">        It calculates the square of the total plan time.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Cost value.</span>

<span class="sd">        .. warning:: Optimization solver can misbehave for costs too big (:math:`&gt; 10^{6}`).</span>

<span class="sd">        .. note:: This method is just a call to the :meth:`_ls_sa_criterion` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_sa_criterion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._ls_co_feqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._ls_co_feqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_ls_co_feqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **equations** constraints values for the last section of the plan when</span>
<span class="sd">        there are conflicts.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the equations&#39; values.</span>

<span class="sd">        .. note:: This method is just a call to the :meth:`_ls_co_criterion` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_sa_feqcons</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._ls_co_fieqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._ls_co_fieqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_ls_co_fieqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **inequations** constraints values for the last section of the plan when</span>
<span class="sd">        there are conflicts.</span>

<span class="sd">        The following expressions are evaluated:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left\lbrace\\begin{array}{lcl}</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{N_s-2,\ sec}),\dotsc,z^{(l)}(t_{N_s-2,\ sec}))|\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-2,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \end{array}\\right.</span>

<span class="sd">        where:</span>
<span class="sd">            =========== =================================================</span>
<span class="sd">            :math:`sec` indicates the current plan section.</span>
<span class="sd">            :math:`O_i` is the ith detected obstacle.</span>
<span class="sd">            :math:`M`   is the number of detected obstacles.</span>
<span class="sd">            :math:`N_s` is the number of time samples for a plan section.</span>
<span class="sd">            =========== =================================================</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the inequations&#39; values.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Take into account the coflict constraints!</span>
<span class="sd">            The way it is this method is identical to the :meth:`_ls_sa_fieqcons` method,</span>
<span class="sd">            which is pretty bad.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt_final</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dt_final</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_final</span><span class="p">)</span>

        <span class="n">mtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_final</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">)</span>

        <span class="c"># get a list over time of the matrix [z dz ddz](t) t in [tk, tk+Tp]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="n">mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="n">mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dztTp</span> <span class="o">=</span> <span class="p">[</span><span class="n">dzt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">dzt</span> <span class="ow">in</span> <span class="n">dz</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c"># get a list over time of command values u(t)</span>
        <span class="n">utTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c"># get a list over time of values q(t)</span>
        <span class="n">qtTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c">## Obstacles constraints</span>
        <span class="c"># N_s*nb_obst_detected</span>
        <span class="n">obst_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detected_obst_idxs</span><span class="p">:</span>
            <span class="n">obst_cons</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">pt_2_obst</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>\
                    <span class="k">for</span> <span class="n">qt</span> <span class="ow">in</span> <span class="n">qtTp</span><span class="p">]</span>

        <span class="c">## Max speed constraints</span>
        <span class="c"># N_s*u_dim inequations</span>
        <span class="n">max_speed_cons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)]</span>\
                <span class="k">for</span> <span class="n">ut</span> <span class="ow">in</span> <span class="n">utTp</span><span class="p">]))</span>

        <span class="c"># Create final array</span>
        <span class="n">ieq_cons</span> <span class="o">=</span> <span class="n">obst_cons</span> <span class="o">+</span> <span class="n">max_speed_cons</span>
        <span class="c"># Count how many inequations are not respected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_ieq_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">ieq</span> <span class="k">for</span> <span class="n">ieq</span> <span class="ow">in</span> <span class="n">ieq_cons</span> <span class="k">if</span> <span class="n">ieq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ieq_cons</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._co_criterion"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._co_criterion">[docs]</a>    <span class="k">def</span> <span class="nf">_co_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cost function to be minimized used for optimizing</span>
<span class="sd">        the first and intermediaries sections of the plan when conflicts are detected.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Cost value.</span>

<span class="sd">        .. warning:: Optimization solver can misbehave for costs too big (:math:`&gt; 10^{6}`).</span>

<span class="sd">        .. note:: This method is just a call to the :meth:`_sa_criterion` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_criterion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._co_feqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._co_feqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_co_feqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **equations** constraints values for the first and intermadiaries</span>
<span class="sd">        section of the plan when there are conflicts.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the equations&#39; values.</span>

<span class="sd">        .. note:: This method is just a call to the :meth:`_sa_feqcons` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_feqcons</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._co_fieqcons"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._co_fieqcons">[docs]</a>    <span class="k">def</span> <span class="nf">_co_fieqcons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the **inequations** constraints values for the first and intermadiaries</span>
<span class="sd">        section of the plan when there are conflicts.</span>

<span class="sd">        The following expressions are evaluated:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left\lbrace\\begin{array}{lcl}</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec}))|\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec}))|\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            u_{max} - |\\varphi_2(z(t_{N_s-1,\ sec}),\dotsc,z^{(l)}(t_{N_s-1,\ sec}))|\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_0)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_0)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),\dotsc,z^{(l)}(t_{1,\ sec})), O_1)\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),\dotsc,z^{(l)}(t_{2,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_1)\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{1,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{2,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{2,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \dotsc\\\\</span>
<span class="sd">            \mathrm{pt2obstacle}(\\varphi_1(z(t_{N_s-1,\ sec}),</span>
<span class="sd">            \dotsc,z^{(l)}(t_{N_s-1,\ sec})), O_{M-1})\\\\</span>
<span class="sd">            \mathrm{collision()}\\\\</span>
<span class="sd">            \mathrm{communication()}\\\\</span>
<span class="sd">            \mathrm{deviation()}</span>
<span class="sd">            \end{array}\\right.</span>

<span class="sd">        where:</span>
<span class="sd">            =========== =================================================</span>
<span class="sd">            :math:`sec` indicates the current plan section.</span>
<span class="sd">            :math:`O_i` is the ith detected obstacle.</span>
<span class="sd">            :math:`M`   is the number of detected obstacles.</span>
<span class="sd">            :math:`N_s` is the number of time samples for a plan section.</span>
<span class="sd">            =========== =================================================</span>

<span class="sd">        .. todo:: Add the expression for collision, communication and deviation constraints.</span>

<span class="sd">        Input</span>
<span class="sd">            *x*: optimization argument.</span>

<span class="sd">        Return</span>
<span class="sd">            Array with the inequations&#39; values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>

        <span class="c"># get a list over time of the matrix [z dz ddz](t) t in [tk, tk+Tp]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">C</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dztTp</span> <span class="o">=</span> <span class="p">[</span><span class="n">dzt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">dzt</span> <span class="ow">in</span> <span class="n">dz</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c"># get a list over time of command values u(t)</span>
        <span class="n">utTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c"># get a list over time of values q(t)</span>
        <span class="n">qtTp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">,</span> <span class="n">dztTp</span><span class="p">)</span>

        <span class="c">## Obstacles constraints</span>
        <span class="c"># N_s*nb_obst_detected</span>
        <span class="n">obst_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detected_obst_idxs</span><span class="p">:</span>
            <span class="n">obst_cons</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_obst</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">pt_2_obst</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>\
                    <span class="k">for</span> <span class="n">qt</span> <span class="ow">in</span> <span class="n">qtTp</span><span class="p">]</span>

        <span class="c">## Max speed constraints</span>
        <span class="c"># N_s*u_dim inequations</span>
        <span class="n">max_speed_cons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)]</span>\
                <span class="k">for</span> <span class="n">ut</span> <span class="ow">in</span> <span class="n">utTp</span><span class="p">]))</span>

        <span class="c">## Communication constraints</span>
        <span class="n">com_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_robots_idx</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">done_planning</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">d_ip</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>\
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">latest_z</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">latest_z</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d_ip</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>\
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">intended_path_z1</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">intended_path_z2</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">]]))</span>
                <span class="n">com_cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_com_range</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_epsilon</span> <span class="o">-</span> <span class="n">d_ip</span><span class="p">)</span>

        <span class="c">## Collision constraints</span>
        <span class="n">collision_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collision_robots_idx</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">done_planning</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">d_secu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
                    <span class="n">d_ip</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>\
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">latest_z</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">latest_z</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d_secu</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
                    <span class="n">d_ip</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>\
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">intended_path_z1</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">intended_path_z2</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">]]))</span>
                <span class="n">collision_cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_ip</span> <span class="o">-</span> <span class="n">d_secu</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_epsilon</span><span class="p">)</span>

        <span class="c">## Deformation from intended path constraint</span>
        <span class="n">deform_cons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">d_ii</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sa_dz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">deform_cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_def_epsilon</span> <span class="o">-</span> <span class="n">d_ii</span><span class="p">)</span>

        <span class="c"># Create final array</span>
        <span class="n">ieq_cons</span> <span class="o">=</span> <span class="n">obst_cons</span> <span class="o">+</span> <span class="n">max_speed_cons</span> <span class="o">+</span> <span class="n">com_cons</span> <span class="o">+</span> <span class="n">collision_cons</span> <span class="o">+</span> <span class="n">deform_cons</span>

        <span class="c"># Count how many inequations are not respected</span>
        <span class="n">unsatisf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">ieq</span> <span class="k">for</span> <span class="n">ieq</span> <span class="ow">in</span> <span class="n">ieq_cons</span> <span class="k">if</span> <span class="n">ieq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_ieq_values</span> <span class="o">=</span> <span class="n">unsatisf_list</span>

        <span class="c"># return arrray where each element is an inequation constraint</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ieq_cons</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Robot._compute_conflicts"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._compute_conflicts">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_conflicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine the list of conflictous robots among all other robots.</span>
<span class="sd">        This method updates the :attr:`_conflict_robots_idx` private attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collision_robots_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_com_robots_idx</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_robots</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">done_planning</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d_secu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
                <span class="n">linspeed_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c"># TODO each robot must know the radius of the other robot</span>
                <span class="n">d_secu</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
                <span class="n">linspeed_max</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">d_ip</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c"># TODO shouldn&#39;t it be Tc instead of Tp?</span>
            <span class="k">if</span> <span class="n">d_ip</span> <span class="o">&lt;=</span> <span class="n">d_secu</span> <span class="o">+</span> <span class="n">linspeed_max</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tp</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collision_robots_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neigh</span><span class="p">:</span> <span class="c"># if the ith robot is a communication neighbor</span>
                <span class="c"># TODO right side of condition should be min(self._com_range, ...</span>
                <span class="c"># ... self._com_link.com_range[i])</span>
                <span class="k">if</span> <span class="n">d_ip</span> <span class="o">+</span> <span class="n">linspeed_max</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tp</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_range</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_com_robots_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_robots_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collision_robots_idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_com_robots_idx</span>
</div>
<div class="viewcode-block" id="Robot._solve_opt_pbl"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._solve_opt_pbl">[docs]</a>    <span class="k">def</span> <span class="nf">_solve_opt_pbl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Call the optimization solver with the appropriate parameters and parse</span>
<span class="sd">        the information returned by it. This method updates the :attr:`_C`, :attr:`_dt_final`</span>
<span class="sd">        and :attr:`_t_final` attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">!=</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_alone</span><span class="p">:</span>
                <span class="n">p_criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_criterion</span>
                <span class="n">p_eqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_feqcons</span>
                <span class="n">p_ieqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sa_fieqcons</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_co_criterion</span>
                <span class="n">p_eqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_co_feqcons</span>
                <span class="n">p_ieqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_co_fieqcons</span>

            <span class="n">init_guess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acc</span>
            <span class="n">maxit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxit</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ms&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fs_maxit</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_alone</span><span class="p">:</span>
                <span class="n">p_criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_sa_criterion</span>
                <span class="n">p_eqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_sa_feqcons</span>
                <span class="n">p_ieqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_sa_fieqcons</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_co_criterion</span>
                <span class="n">p_eqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_co_feqcons</span>
                <span class="n">p_ieqcons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_co_fieqcons</span>

            <span class="n">init_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_est_dtime</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">))</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="mf">1e-1</span>
            <span class="n">maxit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_maxit</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">fmin_slsqp</span><span class="p">(</span>
            <span class="n">p_criterion</span><span class="p">,</span>
            <span class="n">init_guess</span><span class="p">,</span>
            <span class="n">eqcons</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">f_eqcons</span><span class="o">=</span><span class="n">p_eqcons</span><span class="p">,</span>
            <span class="n">ieqcons</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">f_ieqcons</span><span class="o">=</span><span class="n">p_ieqcons</span><span class="p">,</span>
            <span class="n">iprint</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="nb">iter</span><span class="o">=</span><span class="n">maxit</span><span class="p">,</span>
            <span class="n">acc</span><span class="o">=</span><span class="n">acc</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c">#imode = output[3]</span>
            <span class="c"># TODO handle optimization exit mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dt_final</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt_final</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span>
<span class="c">#            #imode = output[3]</span>
<span class="c">#            # TODO handle optimization exit mode</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_it</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exit_mode</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Robot._plan_section"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._plan_section">[docs]</a>    <span class="k">def</span> <span class="nf">_plan_section</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This method takes care of planning a section of the final path over a :math:`T_{d/p}`</span>
<span class="sd">        time horizon.</span>

<span class="sd">        It also performs syncronization and data exchange among the robots.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">btic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c"># update detected obstacles list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detect_obst</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">gen_ctrlpts_from_curve</span><span class="p">(</span><span class="n">last_ctrl_pt</span><span class="p">,</span> <span class="n">curve</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Interpolate a given curve by Bezier splines defined by its control points.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">aux_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_knots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">)</span>

            <span class="c"># create b-spline representation of that curve</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">aux_t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">task</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_knots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>\
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curve</span><span class="p">]</span>

            <span class="c"># get the ctrl points</span>
            <span class="n">ctrl</span> <span class="o">=</span> <span class="p">[</span><span class="n">tck_elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,]</span> <span class="k">for</span> <span class="n">tck_elem</span> <span class="ow">in</span> <span class="n">tck</span><span class="p">]</span>

            <span class="c"># initiate C</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">z_dim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c"># first guess for ctrl pts</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ms&#39;</span><span class="p">:</span>
            <span class="c"># get the direction to target state unit vector</span>
            <span class="n">direc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span>
            <span class="n">direc</span> <span class="o">=</span> <span class="n">direc</span><span class="o">/</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">direc</span><span class="p">)</span>

            <span class="c"># estimate position of the last ctrl point</span>
            <span class="n">last_ctrl_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="o">*</span><span class="n">direc</span>

            <span class="c"># create positions thru time assuming that the speed is constant (thus the linspace)</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">z_dim</span><span class="p">):</span>
                <span class="n">curve</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_ctrl_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">)]</span>

            <span class="n">gen_ctrlpts_from_curve</span><span class="p">(</span><span class="n">last_ctrl_pt</span><span class="p">,</span> <span class="n">curve</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>
            <span class="c"># final state</span>
            <span class="n">last_ctrl_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_z</span>

            <span class="n">last_displ</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_final</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>\
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_est_dtime</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c">#+ np.finfo(float).eps</span>

            <span class="n">minus2th_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_ctrl_pt</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">last_displ</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>\
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_final</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_final</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]))</span><span class="o">.</span><span class="n">T</span>

            <span class="c"># create positions thru time assuming that the speed is constant (thus the linspace)</span>
            <span class="n">curve1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curve2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">z_dim</span><span class="p">):</span>
                <span class="n">curve1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">minus2th_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_ctrl_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">curve2</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_ctrl_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">)]</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[(</span><span class="n">ec1</span> <span class="o">+</span> <span class="n">ec2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ec1</span><span class="p">,</span> <span class="n">ec2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">curve1</span><span class="p">,</span> <span class="n">curve2</span><span class="p">)]</span>
<span class="c">#            curve = curve1</span>
            <span class="n">gen_ctrlpts_from_curve</span><span class="p">(</span><span class="n">last_ctrl_pt</span><span class="p">,</span> <span class="n">curve</span><span class="p">)</span>

<span class="c">#            eps = self.k_mod.u_final[0,0]*self._est_dtime/(self._n_ctrlpts-1) + np.finfo(float).eps</span>

            <span class="c"># correcting the [-2]th ctrl pt so it take in account the final state orientation and speed</span>
<span class="c">#            eps = np.finfo(float).eps</span>
<span class="c">#            minus2th_C = last_ctrl_pt.T - eps*np.array(\</span>
<span class="c">#                    [np.cos(self.k_mod.q_final[-1, 0]), np.sin(self.k_mod.q_final[-1, 0])])</span>
<span class="c">#            self._C[self._n_ctrlpts-2,] = minus2th_C</span>

        <span class="k">else</span><span class="p">:</span> <span class="c"># &#39;fs&#39;</span>
            <span class="c"># get the direction to target state unit vector</span>
            <span class="n">direc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span>
            <span class="n">direc</span> <span class="o">=</span> <span class="n">direc</span><span class="o">/</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">direc</span><span class="p">)</span>

            <span class="c"># estimate position of the last ctrl point</span>
            <span class="n">last_ctrl_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="o">*</span><span class="n">direc</span>

            <span class="n">first_displ</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_init</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>\
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_Td</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c">#+ np.finfo(float).eps</span>

            <span class="n">_2th_pt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">first_displ</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>\
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_init</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_init</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]))</span><span class="o">.</span><span class="n">T</span>

            <span class="c"># create positions thru time assuming that the speed is constant (thus the linspace)</span>
            <span class="n">curve1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curve2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">z_dim</span><span class="p">):</span>
                <span class="n">sec2last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">_2th_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_ctrl_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">curve1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sec2last</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">first</span><span class="p">)]</span>
                <span class="n">curve2</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_ctrl_pt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">)]</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">ec1</span> <span class="o">+</span> <span class="n">ec2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ec1</span><span class="p">,</span> <span class="n">ec2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">curve1</span><span class="p">,</span> <span class="n">curve2</span><span class="p">)]</span>
<span class="c">#            curve = curve1</span>
            <span class="n">gen_ctrlpts_from_curve</span><span class="p">(</span><span class="n">last_ctrl_pt</span><span class="p">,</span> <span class="n">curve</span><span class="p">)</span>

            <span class="c"># correcting the [2]th ctrl pt so it take in account the initial state orientation and speed</span>
<span class="c">#            eps = self.k_mod.u_init[0,0]*self._Td/(self._n_ctrlpts-1) + 1e-6</span>
<span class="c">#            _2th_C = final_ctrl_pt.T + eps*np.array(\</span>
<span class="c">#                    [np.cos(self.k_mod.q_final[-1, 0]), np.sin(self.k_mod.q_final[-1, 0])])</span>
<span class="c">#            self._C[self._n_ctrlpts-2,] = minus2_C</span>

<span class="c">#        print &#39;First guess :\n&#39;, self._C</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_std_alone</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solve_opt_pbl</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c"># No need to sync process here, the intended path does impact the conflicts computation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: Time to solve stand alone optimization &#39;</span>
                <span class="s">&#39;problem: {t}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: N of unsatisfied eq: {ne}&#39;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ne</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_eq_values</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: N of unsatisfied ieq: {ne}&#39;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ne</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_ieq_values</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: Summary: {summ} after {it} it.&#39;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">summ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_exit_mode</span><span class="p">,</span> <span class="n">it</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_it</span><span class="p">))</span>

<span class="c">#        if self._final_step:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_final</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_final</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">)</span>

        <span class="n">time_idx</span> <span class="o">=</span> <span class="bp">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ls&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tcd_idx</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:],</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c">#        TODO verify process safety</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">intended_path_z1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">intended_path_z2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dz</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_conflicts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}@tkref={1:.4f}: $$$$$$$$ CONFLICT LIST $$$$$$$$: {2}&#39;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_robots_idx</span><span class="p">))</span>

        <span class="c"># Sync with every robot on the conflict list</span>
        <span class="c">#  1. notify every robot waiting on this robot that it ready for conflict solving</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
        <span class="c">#  2. check if the robots on this robot conflict list are ready</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_robots_idx</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="c"># Now is safe to read the all robots&#39; in the conflict list intended paths (or are done planning)</span>

<span class="c">#        if self._conflict_robots_idx != [] and False:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_robots_idx</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">!=</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_std_alone</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c">#            self._conflict_dz = [self._read_com_link()]</span>
<span class="c">#            self._read_com_link()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_sa_dz</span> <span class="o">=</span> <span class="n">dz</span>

            <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_opt_pbl</span><span class="p">()</span>
            <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: Time to solve optimization probl&#39;</span>
                    <span class="s">&#39;em: {t}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: N of unsatisfied eq: {ne}&#39;</span>\
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ne</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_eq_values</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: N of unsatisfied ieq: {ne}&#39;</span>\
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ne</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unsatisf_ieq_values</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}@tkref={tk:.4f}: Summary: {summ} after {it} it.&#39;</span>\
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">summ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_exit_mode</span><span class="p">,</span> <span class="n">it</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_it</span><span class="p">))</span>

<span class="c">#            if self._final_step:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_final</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_final</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">)</span>

            <span class="n">time_idx</span> <span class="o">=</span> <span class="bp">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;ls&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tcp_idx</span><span class="o">+</span><span class="mi">1</span>

            <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">time_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comb_bsp</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">time_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="p">,:],</span> <span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Storing</span>
<span class="c">#        self._all_C[0:self._n_ctrlpts,:] += [self._C[0:self._n_ctrlpts,:]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_dz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">time_idx</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">time_idx</span><span class="p">])</span>
        <span class="c"># TODO rejected path</span>

        <span class="c"># Updating</span>

        <span class="n">latest_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_dz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c"># Sync robots here so no robot computing conflict get the wrong latest_z of some robot</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_robots</span><span class="p">:</span>  <span class="c"># if not all robots are read</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{}: I</span><span class="se">\&#39;</span><span class="s">m going to sleep!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>                                <span class="c"># otherwise wake up everybody</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span><span class="o">.</span><span class="n">value</span> <span class="o">-=</span> <span class="mi">1</span>            <span class="c"># decrement syncer (idem)</span>
<span class="c">#            self._com_link.latest_z[self.eyed] = latest_z</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">latest_z</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">latest_z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>


<span class="c">#        if not self._final_step:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">!=</span> <span class="s">&#39;ls&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_alone</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tcp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span> <span class="o">=</span> <span class="p">[</span><span class="n">tk</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tcp</span> <span class="k">for</span> <span class="n">tk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tcd</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span> <span class="o">=</span> <span class="p">[</span><span class="n">tk</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tcd</span> <span class="k">for</span> <span class="n">tk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span> <span class="o">=</span> <span class="n">latest_z</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latest_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_dz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latest_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_dz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">==</span> <span class="s">&#39;fs&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">=</span> <span class="s">&#39;ms&#39;</span>
        <span class="n">btoc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_comp_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">btoc</span><span class="o">-</span><span class="n">btic</span><span class="p">)</span>

<span class="c">#        print &#39;Solved C :\n&#39;, self._C</span>
</div>
<div class="viewcode-block" id="Robot._plan"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.Robot._plan">[docs]</a>    <span class="k">def</span> <span class="nf">_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Motion/path planner method. At the end of its execution :attr:`rtime`, :attr:`ctime`</span>
<span class="sd">        and :attr:`sol` attributes will be updated with the plan for completing the mission.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{rid}: Init motion planning&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">))</span>

<span class="c">#        self._final_step = False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">=</span> <span class="s">&#39;fs&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Td</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Td</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">)</span>

        <span class="c"># while the remaining dist is greater than the max dist during Tp</span>
<span class="c">#        while LA.norm(self._latest_z - self._final_z) &gt; self._D:</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">remaining_dist</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_z</span><span class="p">)</span>
<span class="c">#            if remaining_dist &lt; self._D:</span>
<span class="c">#                break</span>
<span class="c">#            elif remaining_dist &lt; self._ls_min_dist + self._Tc*self.k_mod.u_max[0,0] and False:</span>
            <span class="k">if</span> <span class="n">remaining_dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_min_dist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}: LAST STEP&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}: Approx remaining dist: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="n">remaining_dist</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}: Usual approx plan dist: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}: Approx gain in dist: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="o">-</span><span class="n">remaining_dist</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}: Last step min dist: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ls_min_dist</span><span class="p">))</span>
                <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">remaining_dist</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_Td</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span><span class="o">*</span><span class="n">scale_factor</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">-</span> <span class="mi">1</span> <span class="c"># nb of ctrl points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="o">*</span><span class="n">scale_factor</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_ctrlpts</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{0}: scale {1} Ns {2:d} Nk {3:d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">,</span>
                        <span class="n">scale_factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_knots</span><span class="p">))</span>
                <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_plan_section</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{}: --------------------------&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">))</span>

<span class="c">#        self._final_step = True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plan_state</span> <span class="o">=</span> <span class="s">&#39;ls&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_est_dtime</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latest_z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_z</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_knots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_est_dtime</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_est_dtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_s</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plan_section</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{}: Finished motion planning&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;R{}: --------------------------&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_dz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtime</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctime</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_comp_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_com_link</span><span class="o">.</span><span class="n">done_planning</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c">#  Notify every robot waiting on this robot that it is ready for the conflict solving</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_syncer_conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eyed</span><span class="p">]</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

        <span class="c"># Make sure any robot waiting on this robot awake before returning</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>               <span class="c"># increment synker</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_robots</span><span class="p">:</span>  <span class="c"># if all robots are read</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tc_syncer_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

<span class="c">###############################################################################</span>
<span class="c"># World</span>
<span class="c">###############################################################################</span></div></div>
<div class="viewcode-block" id="WorldSim"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.WorldSim">[docs]</a><span class="k">class</span> <span class="nc">WorldSim</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This class is a container of all simulation elements and also the</span>
<span class="sd">    interface for running the simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_id</span><span class="p">,</span> <span class="n">robots</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">,</span> <span class="n">phy_boundary</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sn</span> <span class="o">=</span> <span class="n">name_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span> <span class="o">=</span> <span class="n">robots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obsts</span> <span class="o">=</span> <span class="n">obstacles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span> <span class="o">=</span> <span class="n">robots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_Tc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ph_bound</span> <span class="o">=</span> <span class="n">phy_boundary</span>

<div class="viewcode-block" id="WorldSim.run"><a class="viewcode-back" href="../Multi-robot motion planner.html#planning_sim.WorldSim.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run simulation by first calling the :py:meth:`multiprocessing.Process.start` method on</span>
<span class="sd">        the :attr:`Robot.planning_process` to</span>
<span class="sd">        initiate the motion planning of each robot. And secondly by parsing theirs solutions and</span>
<span class="sd">        prompting the option to plot/save it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_robots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)</span>
        <span class="n">N_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_N_s</span>

        <span class="c"># Multiprocessing stuff ############################################</span>
        <span class="c"># Log Lock</span>
        <span class="n">log_lock</span> <span class="o">=</span> <span class="n">mpc</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

        <span class="c"># Conditions</span>
        <span class="n">tc_syncer_cond</span> <span class="o">=</span> <span class="n">mpc</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>
        <span class="n">conflict_syncer_conds</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpc</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">)]</span>

        <span class="c"># Shared memory for sync</span>
        <span class="n">tc_syncer</span> <span class="o">=</span> <span class="n">mpc</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># unsigned int</span>
        <span class="n">conflict_syncer</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpc</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">)]</span>

        <span class="c"># Shared memory for communication link</span>
        <span class="n">done_planning</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpc</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">)]</span>
        <span class="n">intended_path_z1</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpc</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">N_s</span><span class="o">*</span><span class="p">[</span><span class="mf">0.0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">)]</span>
        <span class="n">intended_path_z2</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpc</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">N_s</span><span class="o">*</span><span class="p">[</span><span class="mf">0.0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">)]</span>
        <span class="n">latest_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpc</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_init</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> \
                <span class="n">r</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">q_init</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>

        <span class="c"># Packing shared memory into a RobotMsg object</span>
        <span class="n">com_link</span> <span class="o">=</span> <span class="n">RobotMsg</span><span class="p">(</span><span class="n">done_planning</span><span class="p">,</span> <span class="n">intended_path_z1</span><span class="p">,</span> <span class="n">intended_path_z2</span><span class="p">,</span> <span class="n">latest_z</span><span class="p">)</span>

        <span class="c"># More complex and expense shared memory thru a server process manager ...</span>
        <span class="c"># ... (because they can support arbitrary object types)</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="n">mpc</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
        <span class="n">solutions</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">))</span>
        <span class="n">race_time</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">))</span>
        <span class="n">comp_time</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">))</span>
        <span class="c">####################################################################</span>

        <span class="c"># Setting multiprocessing stuff for every robot</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;log_lock&#39;</span><span class="p">,</span> <span class="n">log_lock</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;tc_syncer&#39;</span><span class="p">,</span> <span class="n">tc_syncer</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;tc_syncer_cond&#39;</span><span class="p">,</span> <span class="n">tc_syncer_cond</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;conflict_syncer&#39;</span><span class="p">,</span> <span class="n">conflict_syncer</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;conflict_syncer_conds&#39;</span><span class="p">,</span> <span class="n">conflict_syncer_conds</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;com_link&#39;</span><span class="p">,</span> <span class="n">com_link</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;sol&#39;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;rtime&#39;</span><span class="p">,</span> <span class="n">race_time</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;ctime&#39;</span><span class="p">,</span> <span class="n">comp_time</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>

        <span class="c"># Make all robots plan their trajectories</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">planning_process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>
        <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">planning_process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">]</span>

        <span class="c"># Reshaping the solution</span>
        <span class="n">path</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
        <span class="n">seg_pts_idx</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">seg_pts_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">seg_pts_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># From [z dz ddz](t) get q(t) and u(t)</span>
        <span class="n">zdzddz</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">zdzddz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_dim</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c"># get a list over time of command values u(t)</span>
        <span class="n">ut</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_2</span><span class="p">,</span> <span class="n">zdzddz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c"># Fixing division by near-zero value when calculating angspeed for plot</span>
            <span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_init</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_final</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># get a list over time of values q(t)</span>
        <span class="n">qt</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">phi_1</span><span class="p">,</span> <span class="n">zdzddz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c"># get &quot;race&quot; times (time spend on each section of the path planning)</span>
        <span class="n">rtime</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">rtime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rtime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c"># get computation times</span>
        <span class="n">ctime</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c"># Logging simulation summary</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
            <span class="n">ctime_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">g_max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: TOT: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">rtime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: NSE: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime_len</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: FIR: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: LAS: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">g_max_idx</span> <span class="o">==</span> <span class="n">ctime_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: LMA: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: LMA: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ctime_len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: MAX: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: MIN: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: AVG: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: RMP: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="p">))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: RMG: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: MAX: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: MIN: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: AVG: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: RMP: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="p">))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;R{rid}: RMG: {d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rid</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">ctime</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_Tc</span><span class="p">))</span>

        <span class="c"># PLOT ###############################################################</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;Want to see the result plotted? [y/n]: &quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;n&#39;</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;N&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;y&#39;</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;I&#39;ll take that as an </span><span class="se">\&#39;</span><span class="s">n</span><span class="se">\&#39;</span><span class="s">.&quot;</span><span class="p">)</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;n&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;y&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;n&#39;</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Oops! That was no valid characther. Try again...&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Good bye!&quot;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Interactive plot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s">&quot;../traces/pngs/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_sn</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Probably the output directory already exists, going to overwrite content&#39;</span><span class="p">)</span>

        <span class="n">fig_s</span><span class="p">,</span> <span class="n">axarray</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">axarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;v(m/s)&#39;</span><span class="p">)</span>
        <span class="n">axarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Linear speed&#39;</span><span class="p">)</span>
        <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;time(s)&#39;</span><span class="p">)</span>
        <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;w(rad/s)&#39;</span><span class="p">)</span>
        <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Angular speed&#39;</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;x(m)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;y(m)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Generated trajectory&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">aux</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))]</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Creating obstacles in the plot</span>
            <span class="p">[</span><span class="n">obst</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span> <span class="k">for</span> <span class="n">obst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obsts</span><span class="p">]</span>

            <span class="n">plt_paths</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
            <span class="n">plt_seg_pts</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
            <span class="n">plt_robots_c</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
            <span class="n">plt_robots_t</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
                <span class="n">plt_paths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">plt_seg_pts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">seg_pts_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> \
                        <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">seg_pts_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">plt_robots_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="c"># position</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="c"># radius</span>
                        <span class="n">color</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">,</span>
                        <span class="n">ls</span> <span class="o">=</span> <span class="s">&#39;solid&#39;</span><span class="p">,</span>
                        <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rho</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[[</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> \
                        <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> \
                        <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> \
                        <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]])</span>
                <span class="n">plt_robots_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

            <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">plt_robots_c</span><span class="p">]</span>
            <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">plt_robots_t</span><span class="p">]</span>
            <span class="c"># BUG TODO</span>
            <span class="c"># This savefig chashes for initial robot position = (0,0)</span>
<span class="c">#            for i in range(1, 10):</span>
<span class="c">#                fig.savefig(&#39;../traces/pngs/multirobot-path-&#39;+str(i)+&#39;.png&#39;)</span>

            <span class="n">ctr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">ctr</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">plt_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xdata</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ctr</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">plt_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ctr</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg_pts_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span>  <span class="n">ctr</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="p">]</span>
                        <span class="n">plt_seg_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xdata</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">aux</span><span class="p">])</span>
                        <span class="n">plt_seg_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">aux</span><span class="p">])</span>
                        <span class="n">plt_robots_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctr</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctr</span><span class="p">]</span>
                        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rho</span>
                        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                            <span class="p">[</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ctr</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctr</span><span class="p">],</span>
                            <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ctr</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctr</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ctr</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctr</span><span class="p">],</span>
                            <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ctr</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctr</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ctr</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctr</span><span class="p">],</span>
                            <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">qt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ctr</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctr</span><span class="p">]]])</span>
                        <span class="n">plt_robots_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xy</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">):</span>
                    <span class="k">break</span>
<span class="c">#                time.sleep(0.01)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">relim</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;../traces/pngs/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_sn</span><span class="o">+</span><span class="s">&#39;/multirobot-path-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.png&#39;</span><span class="p">,</span>\
                        <span class="n">bbox_inches</span><span class="o">=</span><span class="s">&#39;tight&#39;</span><span class="p">)</span>
            <span class="c">#end</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;../traces/pngs/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_sn</span><span class="o">+</span><span class="s">&#39;/multirobot-path-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ctr</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s">&#39;tight&#39;</span><span class="p">)</span>
<span class="c">#            ax.relim()</span>
<span class="c">#            ax.autoscale_view(True, True, True)</span>
<span class="c">#            fig.canvas.draw()</span>
<span class="c">#            fig.savefig(direc+&#39;pngs/p&#39;+self._sn+&#39;/multirobot-path.png&#39;, bbox_inches=&#39;tight&#39;)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">)):</span>
                <span class="n">linspeed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">angspeed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ut</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">axarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rtime</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">linspeed</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rtime</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">angspeed</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">axarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
            <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
            <span class="n">axarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_robs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">k_mod</span><span class="o">.</span><span class="n">u_max</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">])</span>
<span class="c">#            ax.relim()</span>
<span class="c">#            ax.autoscale_view(True, True, True)</span>
            <span class="n">fig_s</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">fig_s</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;../traces/pngs/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_sn</span><span class="o">+</span><span class="s">&#39;/multirobot-vw.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s">&#39;tight&#39;</span><span class="p">)</span>

            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;Plot again? [y/n]: &quot;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;n&#39;</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;N&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;y&#39;</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span>
                            <span class="k">print</span><span class="p">(</span><span class="s">&quot;I&#39;ll take that as an </span><span class="se">\&#39;</span><span class="s">n</span><span class="se">\&#39;</span><span class="s">.&quot;</span><span class="p">)</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;n&#39;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;y&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="s">&#39;n&#39;</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Oops! That was no valid characther. Try again...&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Good bye!&quot;</span><span class="p">)</span>
                    <span class="k">return</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">&#39;n&#39;</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">axarray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="c">#end</span>
    <span class="c">#end</span>
<span class="c">#end</span>
<span class="c">###############################################################################</span>
<span class="c"># Script</span>
<span class="c">###############################################################################</span>
</div></div>
<span class="k">def</span> <span class="nf">_isobstok</span><span class="p">(</span><span class="n">obsts</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obsts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">obst</span> <span class="ow">in</span> <span class="n">obsts</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">obst</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">obst</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">obst</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">rand_round_obst</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">boundary</span><span class="p">):</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mf">0.0001</span>
    <span class="n">min_radius</span> <span class="o">=</span> <span class="mf">0.15</span>
    <span class="n">max_radius</span> <span class="o">=</span> <span class="mf">0.4</span>
    <span class="n">radius_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_radius</span><span class="p">,</span> <span class="n">max_radius</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">x_range</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">boundary</span><span class="o">.</span><span class="n">x_min</span><span class="o">+</span><span class="n">max_radius</span><span class="p">,</span> <span class="n">boundary</span><span class="o">.</span><span class="n">x_max</span><span class="o">-</span><span class="n">max_radius</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">y_range</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">boundary</span><span class="o">.</span><span class="n">y_min</span><span class="o">+</span><span class="n">max_radius</span><span class="p">,</span> <span class="n">boundary</span><span class="o">.</span><span class="n">y_max</span><span class="o">-</span><span class="n">max_radius</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">obsts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">no</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">x_range</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">y_range</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">radius_range</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_isobstok</span><span class="p">(</span><span class="n">obsts</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">obsts</span> <span class="o">+=</span> <span class="p">[([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">r</span><span class="p">)]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">obsts</span>

<span class="k">def</span> <span class="nf">parse_cmdline</span><span class="p">():</span>
    <span class="c"># parsing command line eventual optmization method options</span>
    <span class="n">scriptname</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">scriptname</span>

<span class="c"># MAIN ########################################################################</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">n_robots</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n_obsts</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">Tc</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">Tp</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">Td</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">N_s</span> <span class="o">=</span> <span class="mi">14</span>
    <span class="n">n_knots</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="mf">1e-3</span>
    <span class="n">maxit</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">fs_maxit</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">ls_maxit</span> <span class="o">=</span> <span class="mi">25</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">seps</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">drho</span> <span class="o">=</span> <span class="mf">3.0</span>
    <span class="n">ls_min_dist</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">ls_time_opt_scale</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">dist_opt_offset</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="c"># unused</span>

    <span class="n">scriptname</span> <span class="o">=</span> <span class="n">parse_cmdline</span><span class="p">()</span>

    <span class="n">name_id</span> <span class="o">=</span> <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_obsts</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Tc</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Tp</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_knots</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">maxit</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fs_maxit</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ls_maxit</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">seps</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">drho</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ls_min_dist</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ls_time_opt_scale</span><span class="p">)</span><span class="o">+</span>\
            <span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">dist_opt_offset</span><span class="p">)</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="n">scriptname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">name_id</span><span class="o">+</span><span class="s">&#39;.log&#39;</span>

<span class="c">#    logging.basicConfig(filename=fname, format=&#39;%(levelname)s:%(message)s&#39;, \</span>
<span class="c">#            filemode=&#39;w&#39;, level=logging.DEBUG)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%(levelname)s</span><span class="s">:</span><span class="si">%(message)s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

    <span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">([</span><span class="o">-</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">])</span>

<span class="c">#    obst_info = rand_round_obst(n_obsts, Boundary([-1., 1.], [0.8, 5.2]))</span>
<span class="c">#    print &#39;OBSTS\n&#39;, obst_info</span>

    <span class="c"># 0 obsts</span>
    <span class="k">if</span> <span class="n">n_obsts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">obst_info</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">n_obsts</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">obst_info</span> <span class="o">=</span> <span class="p">[</span><span class="c">#([0.0, 1.6], 0.3),</span>
                <span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="mf">0.35</span><span class="p">),</span> <span class="p">([</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="mf">0.35</span><span class="p">)]</span>
    <span class="c"># 3 obsts</span>
    <span class="k">elif</span> <span class="n">n_obsts</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
<span class="c">#        obst_info = [([0.55043504350435046, 1.9089108910891091], 0.31361636163616358),</span>
<span class="c">#                ([-0.082028202820282003, 3.6489648964896491], 0.32471747174717469),</span>
<span class="c">#                ([0.37749774977497741, 4.654905490549055], 0.16462646264626463)]</span>
        <span class="n">obst_info</span> <span class="o">=</span> <span class="p">[([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">],</span> <span class="mf">0.3</span><span class="p">),</span>
                <span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="mf">0.35</span><span class="p">),</span> <span class="p">([</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="mf">0.35</span><span class="p">)]</span>
    <span class="c"># 6 obsts</span>
    <span class="k">elif</span> <span class="n">n_obsts</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">obst_info</span> <span class="o">=</span> <span class="p">[([</span><span class="o">-</span><span class="mf">0.35104510451045101</span><span class="p">,</span> <span class="mf">1.3555355535553557</span><span class="p">],</span> <span class="mf">0.38704870487048704</span><span class="p">),</span>
                <span class="p">([</span><span class="mf">0.21441144114411448</span><span class="p">,</span> <span class="mf">2.5279927992799281</span><span class="p">],</span> <span class="mf">0.32584258425842583</span><span class="p">),</span>
                <span class="p">([</span><span class="o">-</span><span class="mf">0.3232123212321232</span><span class="p">,</span> <span class="mf">4.8615661566156621</span><span class="p">],</span> <span class="mf">0.23165816581658166</span><span class="p">),</span>
                <span class="p">([</span><span class="mf">0.098239823982398278</span><span class="p">,</span> <span class="mf">3.975877587758776</span><span class="p">],</span> <span class="mf">0.31376637663766377</span><span class="p">),</span>
                <span class="p">([</span><span class="mf">0.62277227722772288</span><span class="p">,</span> <span class="mf">1.247884788478848</span><span class="p">],</span> <span class="mf">0.1802030203020302</span><span class="p">),</span>
                <span class="p">([</span><span class="mf">1.16985698569856988</span><span class="p">,</span> <span class="mf">3.6557155715571559</span><span class="p">],</span> <span class="mf">0.25223522352235223</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Only 3 or 6 obstacles configurations are permited&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Using 3 obstacles configuration&quot;</span><span class="p">)</span>
        <span class="n">obst_info</span> <span class="o">=</span> <span class="p">[([</span><span class="mf">0.55043504350435046</span><span class="p">,</span> <span class="mf">1.9089108910891091</span><span class="p">],</span> <span class="mf">0.31361636163616358</span><span class="p">),</span>
                <span class="p">([</span><span class="o">-</span><span class="mf">0.082028202820282003</span><span class="p">,</span> <span class="mf">3.6489648964896491</span><span class="p">],</span> <span class="mf">0.32471747174717469</span><span class="p">),</span>
                <span class="p">([</span><span class="mf">0.37749774977497741</span><span class="p">,</span> <span class="mf">4.654905490549055</span><span class="p">],</span> <span class="mf">0.16462646264626463</span><span class="p">)]</span>

    <span class="n">obstacles</span> <span class="o">=</span> <span class="p">[</span><span class="n">RoundObstacle</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obst_info</span><span class="p">]</span>
<span class="c">#    obstacles += [PolygonObstacle(np.array([[0,1],[1,0],[3,0],[4,2]]))]</span>

    <span class="n">kine_models</span> <span class="o">=</span> <span class="p">[</span><span class="n">UnicycleKineModel</span><span class="p">(</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">],</span> <span class="c"># q_initial</span>
            <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span>  <span class="mf">5.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">],</span> <span class="c"># q_final</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>          <span class="c"># u_initial</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>          <span class="c"># u_final</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">5.0</span><span class="p">]),</span>          <span class="c"># u_max</span>
            <span class="n">UnicycleKineModel</span><span class="p">(</span>
            <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">],</span> <span class="c"># q_initial</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">],</span> <span class="c"># q_final</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>          <span class="c"># u_initial</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>          <span class="c"># u_final</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">5.0</span><span class="p">])]</span>          <span class="c"># u_max</span>
<span class="c">#            UnicycleKineModel(</span>
<span class="c">#            [-2.4,  0.1, 0.0], # q_initial</span>
<span class="c">#            [2.6, -1.5, 0.0], # q_final</span>
<span class="c">#            [0.0,  0.0],          # u_initial</span>
<span class="c">#            [0.0,  0.0],          # u_final</span>
<span class="c">#            [1.0,  5.0])]          # u_max</span>

    <span class="n">robots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_robots</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n_robots</span><span class="p">:</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">robots</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Robot</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span>                      <span class="c"># Robot ID</span>
            <span class="n">kine_models</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>         <span class="c"># kinetic model</span>
            <span class="n">obstacles</span><span class="p">,</span>              <span class="c"># all obstacles</span>
            <span class="n">boundary</span><span class="p">,</span>               <span class="c"># planning plane boundary</span>
            <span class="n">neigh</span><span class="p">,</span>                  <span class="c"># neighbors to whom this robot shall talk ...</span>
                                    <span class="c">#...(used for conflict only, not for real comm between process)</span>
            <span class="n">N_s</span><span class="o">=</span><span class="n">N_s</span><span class="p">,</span>                <span class="c"># numbers samplings for each planning interval</span>
            <span class="n">n_knots</span><span class="o">=</span><span class="n">n_knots</span><span class="p">,</span>        <span class="c"># number of knots for b-spline interpolation</span>
            <span class="n">Tc</span><span class="o">=</span><span class="n">Tc</span><span class="p">,</span>                  <span class="c"># computation time</span>
            <span class="n">Tp</span><span class="o">=</span><span class="n">Tp</span><span class="p">,</span>                  <span class="c"># planning horizon</span>
            <span class="n">Td</span><span class="o">=</span><span class="n">Tp</span><span class="p">,</span>
            <span class="n">def_epsilon</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span>       <span class="c"># in meters</span>
            <span class="n">safe_epsilon</span><span class="o">=</span><span class="n">seps</span><span class="p">,</span>      <span class="c"># in meters</span>
            <span class="n">detec_rho</span><span class="o">=</span><span class="n">drho</span><span class="p">,</span>
            <span class="n">ls_time_opt_scale</span> <span class="o">=</span> <span class="n">ls_time_opt_scale</span><span class="p">,</span>
            <span class="n">dist_opt_offset</span> <span class="o">=</span> <span class="n">dist_opt_offset</span><span class="p">,</span>          <span class="c"># TODO param deprecated</span>
            <span class="n">ls_min_dist</span> <span class="o">=</span> <span class="n">ls_min_dist</span><span class="p">)]</span>                 <span class="c"># planning horizon (for stand alone plan)</span>

    <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;acc&#39;</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">robots</span><span class="p">]</span> <span class="c"># accuracy (hard to understand the physical meaning of this)</span>
    <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;maxit&#39;</span><span class="p">,</span> <span class="n">maxit</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">robots</span><span class="p">]</span> <span class="c"># max number of iterations for intermediary steps</span>
    <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;ls_maxit&#39;</span><span class="p">,</span> <span class="n">ls_maxit</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">robots</span><span class="p">]</span> <span class="c"># max number of iterations for the last step</span>
    <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">&#39;fs_maxit&#39;</span><span class="p">,</span> <span class="n">fs_maxit</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">robots</span><span class="p">]</span> <span class="c"># max number of iterations for the first step</span>

    <span class="n">world_sim</span> <span class="o">=</span> <span class="n">WorldSim</span><span class="p">(</span><span class="n">name_id</span><span class="p">,</span> <span class="n">robots</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span> <span class="c"># create the world</span>

    <span class="n">summary_info</span> <span class="o">=</span> <span class="n">world_sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span> <span class="c"># run simulation</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Motion Planning 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, José MENDES.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>